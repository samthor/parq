//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//

// const thrift = require('thrift');
// const Thrift = thrift.Thrift;
// const Int64 = require('node-int64');

import { ThriftType } from '../../../src/thrift/types';

export const Thrift = { Type: ThriftType };

export const module = {
  exports: {},
};

export const ttypes = (module.exports = {});
ttypes.Type = {
  0: 'BOOLEAN',
  BOOLEAN: 0,
  1: 'INT32',
  INT32: 1,
  2: 'INT64',
  INT64: 2,
  3: 'INT96',
  INT96: 3,
  4: 'FLOAT',
  FLOAT: 4,
  5: 'DOUBLE',
  DOUBLE: 5,
  6: 'BYTE_ARRAY',
  BYTE_ARRAY: 6,
  7: 'FIXED_LEN_BYTE_ARRAY',
  FIXED_LEN_BYTE_ARRAY: 7,
};
ttypes.ConvertedType = {
  0: 'UTF8',
  UTF8: 0,
  1: 'MAP',
  MAP: 1,
  2: 'MAP_KEY_VALUE',
  MAP_KEY_VALUE: 2,
  3: 'LIST',
  LIST: 3,
  4: 'ENUM',
  ENUM: 4,
  5: 'DECIMAL',
  DECIMAL: 5,
  6: 'DATE',
  DATE: 6,
  7: 'TIME_MILLIS',
  TIME_MILLIS: 7,
  8: 'TIME_MICROS',
  TIME_MICROS: 8,
  9: 'TIMESTAMP_MILLIS',
  TIMESTAMP_MILLIS: 9,
  10: 'TIMESTAMP_MICROS',
  TIMESTAMP_MICROS: 10,
  11: 'UINT_8',
  UINT_8: 11,
  12: 'UINT_16',
  UINT_16: 12,
  13: 'UINT_32',
  UINT_32: 13,
  14: 'UINT_64',
  UINT_64: 14,
  15: 'INT_8',
  INT_8: 15,
  16: 'INT_16',
  INT_16: 16,
  17: 'INT_32',
  INT_32: 17,
  18: 'INT_64',
  INT_64: 18,
  19: 'JSON',
  JSON: 19,
  20: 'BSON',
  BSON: 20,
  21: 'INTERVAL',
  INTERVAL: 21,
};
ttypes.FieldRepetitionType = {
  0: 'REQUIRED',
  REQUIRED: 0,
  1: 'OPTIONAL',
  OPTIONAL: 1,
  2: 'REPEATED',
  REPEATED: 2,
};
ttypes.Encoding = {
  0: 'PLAIN',
  PLAIN: 0,
  2: 'PLAIN_DICTIONARY',
  PLAIN_DICTIONARY: 2,
  3: 'RLE',
  RLE: 3,
  4: 'BIT_PACKED',
  BIT_PACKED: 4,
  5: 'DELTA_BINARY_PACKED',
  DELTA_BINARY_PACKED: 5,
  6: 'DELTA_LENGTH_BYTE_ARRAY',
  DELTA_LENGTH_BYTE_ARRAY: 6,
  7: 'DELTA_BYTE_ARRAY',
  DELTA_BYTE_ARRAY: 7,
  8: 'RLE_DICTIONARY',
  RLE_DICTIONARY: 8,
  9: 'BYTE_STREAM_SPLIT',
  BYTE_STREAM_SPLIT: 9,
};
ttypes.CompressionCodec = {
  0: 'UNCOMPRESSED',
  UNCOMPRESSED: 0,
  1: 'SNAPPY',
  SNAPPY: 1,
  2: 'GZIP',
  GZIP: 2,
  3: 'LZO',
  LZO: 3,
  4: 'BROTLI',
  BROTLI: 4,
  5: 'LZ4',
  LZ4: 5,
  6: 'ZSTD',
  ZSTD: 6,
  7: 'LZ4_RAW',
  LZ4_RAW: 7,
};
ttypes.PageType = {
  0: 'DATA_PAGE',
  DATA_PAGE: 0,
  1: 'INDEX_PAGE',
  INDEX_PAGE: 1,
  2: 'DICTIONARY_PAGE',
  DICTIONARY_PAGE: 2,
  3: 'DATA_PAGE_V2',
  DATA_PAGE_V2: 3,
};
ttypes.BoundaryOrder = {
  0: 'UNORDERED',
  UNORDERED: 0,
  1: 'ASCENDING',
  ASCENDING: 1,
  2: 'DESCENDING',
  DESCENDING: 2,
};
export const Statistics = (module.exports.Statistics = class {
  constructor(args) {
    this.max = null;
    this.min = null;
    this.null_count = null;
    this.distinct_count = null;
    this.max_value = null;
    this.min_value = null;
    if (args) {
      if (args.max !== undefined && args.max !== null) {
        this.max = args.max;
      }
      if (args.min !== undefined && args.min !== null) {
        this.min = args.min;
      }
      if (args.null_count !== undefined && args.null_count !== null) {
        this.null_count = args.null_count;
      }
      if (args.distinct_count !== undefined && args.distinct_count !== null) {
        this.distinct_count = args.distinct_count;
      }
      if (args.max_value !== undefined && args.max_value !== null) {
        this.max_value = args.max_value;
      }
      if (args.min_value !== undefined && args.min_value !== null) {
        this.min_value = args.min_value;
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.STRING) {
            this.max = input.readBinary();
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.STRING) {
            this.min = input.readBinary();
          } else {
            input.skip(ftype);
          }
          break;
        case 3:
          if (ftype == Thrift.Type.I64) {
            this.null_count = input.readI64();
          } else {
            input.skip(ftype);
          }
          break;
        case 4:
          if (ftype == Thrift.Type.I64) {
            this.distinct_count = input.readI64();
          } else {
            input.skip(ftype);
          }
          break;
        case 5:
          if (ftype == Thrift.Type.STRING) {
            this.max_value = input.readBinary();
          } else {
            input.skip(ftype);
          }
          break;
        case 6:
          if (ftype == Thrift.Type.STRING) {
            this.min_value = input.readBinary();
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('Statistics');
    if (this.max !== null && this.max !== undefined) {
      output.writeFieldBegin('max', Thrift.Type.STRING, 1);
      output.writeBinary(this.max);
      output.writeFieldEnd();
    }
    if (this.min !== null && this.min !== undefined) {
      output.writeFieldBegin('min', Thrift.Type.STRING, 2);
      output.writeBinary(this.min);
      output.writeFieldEnd();
    }
    if (this.null_count !== null && this.null_count !== undefined) {
      output.writeFieldBegin('null_count', Thrift.Type.I64, 3);
      output.writeI64(this.null_count);
      output.writeFieldEnd();
    }
    if (this.distinct_count !== null && this.distinct_count !== undefined) {
      output.writeFieldBegin('distinct_count', Thrift.Type.I64, 4);
      output.writeI64(this.distinct_count);
      output.writeFieldEnd();
    }
    if (this.max_value !== null && this.max_value !== undefined) {
      output.writeFieldBegin('max_value', Thrift.Type.STRING, 5);
      output.writeBinary(this.max_value);
      output.writeFieldEnd();
    }
    if (this.min_value !== null && this.min_value !== undefined) {
      output.writeFieldBegin('min_value', Thrift.Type.STRING, 6);
      output.writeBinary(this.min_value);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const StringType = (module.exports.StringType = class {
  constructor(args) {}

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('StringType');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const UUIDType = (module.exports.UUIDType = class {
  constructor(args) {}

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('UUIDType');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const MapType = (module.exports.MapType = class {
  constructor(args) {}

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('MapType');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const ListType = (module.exports.ListType = class {
  constructor(args) {}

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('ListType');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const EnumType = (module.exports.EnumType = class {
  constructor(args) {}

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('EnumType');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const DateType = (module.exports.DateType = class {
  constructor(args) {}

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('DateType');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const NullType = (module.exports.NullType = class {
  constructor(args) {}

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('NullType');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const DecimalType = (module.exports.DecimalType = class {
  constructor(args) {
    this.scale = null;
    this.precision = null;
    if (args) {
      if (args.scale !== undefined && args.scale !== null) {
        this.scale = args.scale;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field scale is unset!',
        );
      }
      if (args.precision !== undefined && args.precision !== null) {
        this.precision = args.precision;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field precision is unset!',
        );
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.I32) {
            this.scale = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.I32) {
            this.precision = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('DecimalType');
    if (this.scale !== null && this.scale !== undefined) {
      output.writeFieldBegin('scale', Thrift.Type.I32, 1);
      output.writeI32(this.scale);
      output.writeFieldEnd();
    }
    if (this.precision !== null && this.precision !== undefined) {
      output.writeFieldBegin('precision', Thrift.Type.I32, 2);
      output.writeI32(this.precision);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const MilliSeconds = (module.exports.MilliSeconds = class {
  constructor(args) {}

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('MilliSeconds');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const MicroSeconds = (module.exports.MicroSeconds = class {
  constructor(args) {}

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('MicroSeconds');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const NanoSeconds = (module.exports.NanoSeconds = class {
  constructor(args) {}

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('NanoSeconds');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const TimeUnit = (module.exports.TimeUnit = class {
  constructor(args) {
    this.MILLIS = null;
    this.MICROS = null;
    this.NANOS = null;
    if (args) {
      if (args.MILLIS !== undefined && args.MILLIS !== null) {
        this.MILLIS = new ttypes.MilliSeconds(args.MILLIS);
      }
      if (args.MICROS !== undefined && args.MICROS !== null) {
        this.MICROS = new ttypes.MicroSeconds(args.MICROS);
      }
      if (args.NANOS !== undefined && args.NANOS !== null) {
        this.NANOS = new ttypes.NanoSeconds(args.NANOS);
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.STRUCT) {
            this.MILLIS = new ttypes.MilliSeconds();
            this.MILLIS.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.STRUCT) {
            this.MICROS = new ttypes.MicroSeconds();
            this.MICROS.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 3:
          if (ftype == Thrift.Type.STRUCT) {
            this.NANOS = new ttypes.NanoSeconds();
            this.NANOS.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('TimeUnit');
    if (this.MILLIS !== null && this.MILLIS !== undefined) {
      output.writeFieldBegin('MILLIS', Thrift.Type.STRUCT, 1);
      this.MILLIS.write(output);
      output.writeFieldEnd();
    }
    if (this.MICROS !== null && this.MICROS !== undefined) {
      output.writeFieldBegin('MICROS', Thrift.Type.STRUCT, 2);
      this.MICROS.write(output);
      output.writeFieldEnd();
    }
    if (this.NANOS !== null && this.NANOS !== undefined) {
      output.writeFieldBegin('NANOS', Thrift.Type.STRUCT, 3);
      this.NANOS.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const TimestampType = (module.exports.TimestampType = class {
  constructor(args) {
    this.isAdjustedToUTC = null;
    this.unit = null;
    if (args) {
      if (args.isAdjustedToUTC !== undefined && args.isAdjustedToUTC !== null) {
        this.isAdjustedToUTC = args.isAdjustedToUTC;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field isAdjustedToUTC is unset!',
        );
      }
      if (args.unit !== undefined && args.unit !== null) {
        this.unit = new ttypes.TimeUnit(args.unit);
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field unit is unset!',
        );
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.BOOL) {
            this.isAdjustedToUTC = input.readBool();
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.STRUCT) {
            this.unit = new ttypes.TimeUnit();
            this.unit.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('TimestampType');
    if (this.isAdjustedToUTC !== null && this.isAdjustedToUTC !== undefined) {
      output.writeFieldBegin('isAdjustedToUTC', Thrift.Type.BOOL, 1);
      output.writeBool(this.isAdjustedToUTC);
      output.writeFieldEnd();
    }
    if (this.unit !== null && this.unit !== undefined) {
      output.writeFieldBegin('unit', Thrift.Type.STRUCT, 2);
      this.unit.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const TimeType = (module.exports.TimeType = class {
  constructor(args) {
    this.isAdjustedToUTC = null;
    this.unit = null;
    if (args) {
      if (args.isAdjustedToUTC !== undefined && args.isAdjustedToUTC !== null) {
        this.isAdjustedToUTC = args.isAdjustedToUTC;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field isAdjustedToUTC is unset!',
        );
      }
      if (args.unit !== undefined && args.unit !== null) {
        this.unit = new ttypes.TimeUnit(args.unit);
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field unit is unset!',
        );
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.BOOL) {
            this.isAdjustedToUTC = input.readBool();
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.STRUCT) {
            this.unit = new ttypes.TimeUnit();
            this.unit.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('TimeType');
    if (this.isAdjustedToUTC !== null && this.isAdjustedToUTC !== undefined) {
      output.writeFieldBegin('isAdjustedToUTC', Thrift.Type.BOOL, 1);
      output.writeBool(this.isAdjustedToUTC);
      output.writeFieldEnd();
    }
    if (this.unit !== null && this.unit !== undefined) {
      output.writeFieldBegin('unit', Thrift.Type.STRUCT, 2);
      this.unit.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const IntType = (module.exports.IntType = class {
  constructor(args) {
    this.bitWidth = null;
    this.isSigned = null;
    if (args) {
      if (args.bitWidth !== undefined && args.bitWidth !== null) {
        this.bitWidth = args.bitWidth;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field bitWidth is unset!',
        );
      }
      if (args.isSigned !== undefined && args.isSigned !== null) {
        this.isSigned = args.isSigned;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field isSigned is unset!',
        );
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.BYTE) {
            this.bitWidth = input.readByte();
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.BOOL) {
            this.isSigned = input.readBool();
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('IntType');
    if (this.bitWidth !== null && this.bitWidth !== undefined) {
      output.writeFieldBegin('bitWidth', Thrift.Type.BYTE, 1);
      output.writeByte(this.bitWidth);
      output.writeFieldEnd();
    }
    if (this.isSigned !== null && this.isSigned !== undefined) {
      output.writeFieldBegin('isSigned', Thrift.Type.BOOL, 2);
      output.writeBool(this.isSigned);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const JsonType = (module.exports.JsonType = class {
  constructor(args) {}

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('JsonType');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const BsonType = (module.exports.BsonType = class {
  constructor(args) {}

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('BsonType');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const LogicalType = (module.exports.LogicalType = class {
  constructor(args) {
    this.STRING = null;
    this.MAP = null;
    this.LIST = null;
    this.ENUM = null;
    this.DECIMAL = null;
    this.DATE = null;
    this.TIME = null;
    this.TIMESTAMP = null;
    this.INTEGER = null;
    this.UNKNOWN = null;
    this.JSON = null;
    this.BSON = null;
    this.UUID = null;
    if (args) {
      if (args.STRING !== undefined && args.STRING !== null) {
        this.STRING = new ttypes.StringType(args.STRING);
      }
      if (args.MAP !== undefined && args.MAP !== null) {
        this.MAP = new ttypes.MapType(args.MAP);
      }
      if (args.LIST !== undefined && args.LIST !== null) {
        this.LIST = new ttypes.ListType(args.LIST);
      }
      if (args.ENUM !== undefined && args.ENUM !== null) {
        this.ENUM = new ttypes.EnumType(args.ENUM);
      }
      if (args.DECIMAL !== undefined && args.DECIMAL !== null) {
        this.DECIMAL = new ttypes.DecimalType(args.DECIMAL);
      }
      if (args.DATE !== undefined && args.DATE !== null) {
        this.DATE = new ttypes.DateType(args.DATE);
      }
      if (args.TIME !== undefined && args.TIME !== null) {
        this.TIME = new ttypes.TimeType(args.TIME);
      }
      if (args.TIMESTAMP !== undefined && args.TIMESTAMP !== null) {
        this.TIMESTAMP = new ttypes.TimestampType(args.TIMESTAMP);
      }
      if (args.INTEGER !== undefined && args.INTEGER !== null) {
        this.INTEGER = new ttypes.IntType(args.INTEGER);
      }
      if (args.UNKNOWN !== undefined && args.UNKNOWN !== null) {
        this.UNKNOWN = new ttypes.NullType(args.UNKNOWN);
      }
      if (args.JSON !== undefined && args.JSON !== null) {
        this.JSON = new ttypes.JsonType(args.JSON);
      }
      if (args.BSON !== undefined && args.BSON !== null) {
        this.BSON = new ttypes.BsonType(args.BSON);
      }
      if (args.UUID !== undefined && args.UUID !== null) {
        this.UUID = new ttypes.UUIDType(args.UUID);
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.STRUCT) {
            this.STRING = new ttypes.StringType();
            this.STRING.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.STRUCT) {
            this.MAP = new ttypes.MapType();
            this.MAP.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 3:
          if (ftype == Thrift.Type.STRUCT) {
            this.LIST = new ttypes.ListType();
            this.LIST.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 4:
          if (ftype == Thrift.Type.STRUCT) {
            this.ENUM = new ttypes.EnumType();
            this.ENUM.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 5:
          if (ftype == Thrift.Type.STRUCT) {
            this.DECIMAL = new ttypes.DecimalType();
            this.DECIMAL.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 6:
          if (ftype == Thrift.Type.STRUCT) {
            this.DATE = new ttypes.DateType();
            this.DATE.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 7:
          if (ftype == Thrift.Type.STRUCT) {
            this.TIME = new ttypes.TimeType();
            this.TIME.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 8:
          if (ftype == Thrift.Type.STRUCT) {
            this.TIMESTAMP = new ttypes.TimestampType();
            this.TIMESTAMP.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 10:
          if (ftype == Thrift.Type.STRUCT) {
            this.INTEGER = new ttypes.IntType();
            this.INTEGER.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 11:
          if (ftype == Thrift.Type.STRUCT) {
            this.UNKNOWN = new ttypes.NullType();
            this.UNKNOWN.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 12:
          if (ftype == Thrift.Type.STRUCT) {
            this.JSON = new ttypes.JsonType();
            this.JSON.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 13:
          if (ftype == Thrift.Type.STRUCT) {
            this.BSON = new ttypes.BsonType();
            this.BSON.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 14:
          if (ftype == Thrift.Type.STRUCT) {
            this.UUID = new ttypes.UUIDType();
            this.UUID.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('LogicalType');
    if (this.STRING !== null && this.STRING !== undefined) {
      output.writeFieldBegin('STRING', Thrift.Type.STRUCT, 1);
      this.STRING.write(output);
      output.writeFieldEnd();
    }
    if (this.MAP !== null && this.MAP !== undefined) {
      output.writeFieldBegin('MAP', Thrift.Type.STRUCT, 2);
      this.MAP.write(output);
      output.writeFieldEnd();
    }
    if (this.LIST !== null && this.LIST !== undefined) {
      output.writeFieldBegin('LIST', Thrift.Type.STRUCT, 3);
      this.LIST.write(output);
      output.writeFieldEnd();
    }
    if (this.ENUM !== null && this.ENUM !== undefined) {
      output.writeFieldBegin('ENUM', Thrift.Type.STRUCT, 4);
      this.ENUM.write(output);
      output.writeFieldEnd();
    }
    if (this.DECIMAL !== null && this.DECIMAL !== undefined) {
      output.writeFieldBegin('DECIMAL', Thrift.Type.STRUCT, 5);
      this.DECIMAL.write(output);
      output.writeFieldEnd();
    }
    if (this.DATE !== null && this.DATE !== undefined) {
      output.writeFieldBegin('DATE', Thrift.Type.STRUCT, 6);
      this.DATE.write(output);
      output.writeFieldEnd();
    }
    if (this.TIME !== null && this.TIME !== undefined) {
      output.writeFieldBegin('TIME', Thrift.Type.STRUCT, 7);
      this.TIME.write(output);
      output.writeFieldEnd();
    }
    if (this.TIMESTAMP !== null && this.TIMESTAMP !== undefined) {
      output.writeFieldBegin('TIMESTAMP', Thrift.Type.STRUCT, 8);
      this.TIMESTAMP.write(output);
      output.writeFieldEnd();
    }
    if (this.INTEGER !== null && this.INTEGER !== undefined) {
      output.writeFieldBegin('INTEGER', Thrift.Type.STRUCT, 10);
      this.INTEGER.write(output);
      output.writeFieldEnd();
    }
    if (this.UNKNOWN !== null && this.UNKNOWN !== undefined) {
      output.writeFieldBegin('UNKNOWN', Thrift.Type.STRUCT, 11);
      this.UNKNOWN.write(output);
      output.writeFieldEnd();
    }
    if (this.JSON !== null && this.JSON !== undefined) {
      output.writeFieldBegin('JSON', Thrift.Type.STRUCT, 12);
      this.JSON.write(output);
      output.writeFieldEnd();
    }
    if (this.BSON !== null && this.BSON !== undefined) {
      output.writeFieldBegin('BSON', Thrift.Type.STRUCT, 13);
      this.BSON.write(output);
      output.writeFieldEnd();
    }
    if (this.UUID !== null && this.UUID !== undefined) {
      output.writeFieldBegin('UUID', Thrift.Type.STRUCT, 14);
      this.UUID.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const SchemaElement = (module.exports.SchemaElement = class {
  constructor(args) {
    this.type = null;
    this.type_length = null;
    this.repetition_type = null;
    this.name = null;
    this.num_children = null;
    this.converted_type = null;
    this.scale = null;
    this.precision = null;
    this.field_id = null;
    this.logicalType = null;
    if (args) {
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      }
      if (args.type_length !== undefined && args.type_length !== null) {
        this.type_length = args.type_length;
      }
      if (args.repetition_type !== undefined && args.repetition_type !== null) {
        this.repetition_type = args.repetition_type;
      }
      if (args.name !== undefined && args.name !== null) {
        this.name = args.name;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field name is unset!',
        );
      }
      if (args.num_children !== undefined && args.num_children !== null) {
        this.num_children = args.num_children;
      }
      if (args.converted_type !== undefined && args.converted_type !== null) {
        this.converted_type = args.converted_type;
      }
      if (args.scale !== undefined && args.scale !== null) {
        this.scale = args.scale;
      }
      if (args.precision !== undefined && args.precision !== null) {
        this.precision = args.precision;
      }
      if (args.field_id !== undefined && args.field_id !== null) {
        this.field_id = args.field_id;
      }
      if (args.logicalType !== undefined && args.logicalType !== null) {
        this.logicalType = new ttypes.LogicalType(args.logicalType);
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.I32) {
            this.type = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.I32) {
            this.type_length = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 3:
          if (ftype == Thrift.Type.I32) {
            this.repetition_type = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 4:
          if (ftype == Thrift.Type.STRING) {
            this.name = input.readString();
          } else {
            input.skip(ftype);
          }
          break;
        case 5:
          if (ftype == Thrift.Type.I32) {
            this.num_children = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 6:
          if (ftype == Thrift.Type.I32) {
            this.converted_type = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 7:
          if (ftype == Thrift.Type.I32) {
            this.scale = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 8:
          if (ftype == Thrift.Type.I32) {
            this.precision = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 9:
          if (ftype == Thrift.Type.I32) {
            this.field_id = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 10:
          if (ftype == Thrift.Type.STRUCT) {
            this.logicalType = new ttypes.LogicalType();
            this.logicalType.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('SchemaElement');
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 1);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.type_length !== null && this.type_length !== undefined) {
      output.writeFieldBegin('type_length', Thrift.Type.I32, 2);
      output.writeI32(this.type_length);
      output.writeFieldEnd();
    }
    if (this.repetition_type !== null && this.repetition_type !== undefined) {
      output.writeFieldBegin('repetition_type', Thrift.Type.I32, 3);
      output.writeI32(this.repetition_type);
      output.writeFieldEnd();
    }
    if (this.name !== null && this.name !== undefined) {
      output.writeFieldBegin('name', Thrift.Type.STRING, 4);
      output.writeString(this.name);
      output.writeFieldEnd();
    }
    if (this.num_children !== null && this.num_children !== undefined) {
      output.writeFieldBegin('num_children', Thrift.Type.I32, 5);
      output.writeI32(this.num_children);
      output.writeFieldEnd();
    }
    if (this.converted_type !== null && this.converted_type !== undefined) {
      output.writeFieldBegin('converted_type', Thrift.Type.I32, 6);
      output.writeI32(this.converted_type);
      output.writeFieldEnd();
    }
    if (this.scale !== null && this.scale !== undefined) {
      output.writeFieldBegin('scale', Thrift.Type.I32, 7);
      output.writeI32(this.scale);
      output.writeFieldEnd();
    }
    if (this.precision !== null && this.precision !== undefined) {
      output.writeFieldBegin('precision', Thrift.Type.I32, 8);
      output.writeI32(this.precision);
      output.writeFieldEnd();
    }
    if (this.field_id !== null && this.field_id !== undefined) {
      output.writeFieldBegin('field_id', Thrift.Type.I32, 9);
      output.writeI32(this.field_id);
      output.writeFieldEnd();
    }
    if (this.logicalType !== null && this.logicalType !== undefined) {
      output.writeFieldBegin('logicalType', Thrift.Type.STRUCT, 10);
      this.logicalType.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const DataPageHeader = (module.exports.DataPageHeader = class {
  constructor(args) {
    this.num_values = null;
    this.encoding = null;
    this.definition_level_encoding = null;
    this.repetition_level_encoding = null;
    this.statistics = null;
    if (args) {
      if (args.num_values !== undefined && args.num_values !== null) {
        this.num_values = args.num_values;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field num_values is unset!',
        );
      }
      if (args.encoding !== undefined && args.encoding !== null) {
        this.encoding = args.encoding;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field encoding is unset!',
        );
      }
      if (args.definition_level_encoding !== undefined && args.definition_level_encoding !== null) {
        this.definition_level_encoding = args.definition_level_encoding;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field definition_level_encoding is unset!',
        );
      }
      if (args.repetition_level_encoding !== undefined && args.repetition_level_encoding !== null) {
        this.repetition_level_encoding = args.repetition_level_encoding;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field repetition_level_encoding is unset!',
        );
      }
      if (args.statistics !== undefined && args.statistics !== null) {
        this.statistics = new ttypes.Statistics(args.statistics);
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.I32) {
            this.num_values = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.I32) {
            this.encoding = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 3:
          if (ftype == Thrift.Type.I32) {
            this.definition_level_encoding = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 4:
          if (ftype == Thrift.Type.I32) {
            this.repetition_level_encoding = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 5:
          if (ftype == Thrift.Type.STRUCT) {
            this.statistics = new ttypes.Statistics();
            this.statistics.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('DataPageHeader');
    if (this.num_values !== null && this.num_values !== undefined) {
      output.writeFieldBegin('num_values', Thrift.Type.I32, 1);
      output.writeI32(this.num_values);
      output.writeFieldEnd();
    }
    if (this.encoding !== null && this.encoding !== undefined) {
      output.writeFieldBegin('encoding', Thrift.Type.I32, 2);
      output.writeI32(this.encoding);
      output.writeFieldEnd();
    }
    if (this.definition_level_encoding !== null && this.definition_level_encoding !== undefined) {
      output.writeFieldBegin('definition_level_encoding', Thrift.Type.I32, 3);
      output.writeI32(this.definition_level_encoding);
      output.writeFieldEnd();
    }
    if (this.repetition_level_encoding !== null && this.repetition_level_encoding !== undefined) {
      output.writeFieldBegin('repetition_level_encoding', Thrift.Type.I32, 4);
      output.writeI32(this.repetition_level_encoding);
      output.writeFieldEnd();
    }
    if (this.statistics !== null && this.statistics !== undefined) {
      output.writeFieldBegin('statistics', Thrift.Type.STRUCT, 5);
      this.statistics.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const IndexPageHeader = (module.exports.IndexPageHeader = class {
  constructor(args) {}

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('IndexPageHeader');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const DictionaryPageHeader = (module.exports.DictionaryPageHeader = class {
  constructor(args) {
    this.num_values = null;
    this.encoding = null;
    this.is_sorted = null;
    if (args) {
      if (args.num_values !== undefined && args.num_values !== null) {
        this.num_values = args.num_values;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field num_values is unset!',
        );
      }
      if (args.encoding !== undefined && args.encoding !== null) {
        this.encoding = args.encoding;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field encoding is unset!',
        );
      }
      if (args.is_sorted !== undefined && args.is_sorted !== null) {
        this.is_sorted = args.is_sorted;
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.I32) {
            this.num_values = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.I32) {
            this.encoding = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 3:
          if (ftype == Thrift.Type.BOOL) {
            this.is_sorted = input.readBool();
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('DictionaryPageHeader');
    if (this.num_values !== null && this.num_values !== undefined) {
      output.writeFieldBegin('num_values', Thrift.Type.I32, 1);
      output.writeI32(this.num_values);
      output.writeFieldEnd();
    }
    if (this.encoding !== null && this.encoding !== undefined) {
      output.writeFieldBegin('encoding', Thrift.Type.I32, 2);
      output.writeI32(this.encoding);
      output.writeFieldEnd();
    }
    if (this.is_sorted !== null && this.is_sorted !== undefined) {
      output.writeFieldBegin('is_sorted', Thrift.Type.BOOL, 3);
      output.writeBool(this.is_sorted);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const DataPageHeaderV2 = (module.exports.DataPageHeaderV2 = class {
  constructor(args) {
    this.num_values = null;
    this.num_nulls = null;
    this.num_rows = null;
    this.encoding = null;
    this.definition_levels_byte_length = null;
    this.repetition_levels_byte_length = null;
    this.is_compressed = true;
    this.statistics = null;
    if (args) {
      if (args.num_values !== undefined && args.num_values !== null) {
        this.num_values = args.num_values;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field num_values is unset!',
        );
      }
      if (args.num_nulls !== undefined && args.num_nulls !== null) {
        this.num_nulls = args.num_nulls;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field num_nulls is unset!',
        );
      }
      if (args.num_rows !== undefined && args.num_rows !== null) {
        this.num_rows = args.num_rows;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field num_rows is unset!',
        );
      }
      if (args.encoding !== undefined && args.encoding !== null) {
        this.encoding = args.encoding;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field encoding is unset!',
        );
      }
      if (
        args.definition_levels_byte_length !== undefined &&
        args.definition_levels_byte_length !== null
      ) {
        this.definition_levels_byte_length = args.definition_levels_byte_length;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field definition_levels_byte_length is unset!',
        );
      }
      if (
        args.repetition_levels_byte_length !== undefined &&
        args.repetition_levels_byte_length !== null
      ) {
        this.repetition_levels_byte_length = args.repetition_levels_byte_length;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field repetition_levels_byte_length is unset!',
        );
      }
      if (args.is_compressed !== undefined && args.is_compressed !== null) {
        this.is_compressed = args.is_compressed;
      }
      if (args.statistics !== undefined && args.statistics !== null) {
        this.statistics = new ttypes.Statistics(args.statistics);
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.I32) {
            this.num_values = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.I32) {
            this.num_nulls = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 3:
          if (ftype == Thrift.Type.I32) {
            this.num_rows = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 4:
          if (ftype == Thrift.Type.I32) {
            this.encoding = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 5:
          if (ftype == Thrift.Type.I32) {
            this.definition_levels_byte_length = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 6:
          if (ftype == Thrift.Type.I32) {
            this.repetition_levels_byte_length = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 7:
          if (ftype == Thrift.Type.BOOL) {
            this.is_compressed = input.readBool();
          } else {
            input.skip(ftype);
          }
          break;
        case 8:
          if (ftype == Thrift.Type.STRUCT) {
            this.statistics = new ttypes.Statistics();
            this.statistics.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('DataPageHeaderV2');
    if (this.num_values !== null && this.num_values !== undefined) {
      output.writeFieldBegin('num_values', Thrift.Type.I32, 1);
      output.writeI32(this.num_values);
      output.writeFieldEnd();
    }
    if (this.num_nulls !== null && this.num_nulls !== undefined) {
      output.writeFieldBegin('num_nulls', Thrift.Type.I32, 2);
      output.writeI32(this.num_nulls);
      output.writeFieldEnd();
    }
    if (this.num_rows !== null && this.num_rows !== undefined) {
      output.writeFieldBegin('num_rows', Thrift.Type.I32, 3);
      output.writeI32(this.num_rows);
      output.writeFieldEnd();
    }
    if (this.encoding !== null && this.encoding !== undefined) {
      output.writeFieldBegin('encoding', Thrift.Type.I32, 4);
      output.writeI32(this.encoding);
      output.writeFieldEnd();
    }
    if (
      this.definition_levels_byte_length !== null &&
      this.definition_levels_byte_length !== undefined
    ) {
      output.writeFieldBegin('definition_levels_byte_length', Thrift.Type.I32, 5);
      output.writeI32(this.definition_levels_byte_length);
      output.writeFieldEnd();
    }
    if (
      this.repetition_levels_byte_length !== null &&
      this.repetition_levels_byte_length !== undefined
    ) {
      output.writeFieldBegin('repetition_levels_byte_length', Thrift.Type.I32, 6);
      output.writeI32(this.repetition_levels_byte_length);
      output.writeFieldEnd();
    }
    if (this.is_compressed !== null && this.is_compressed !== undefined) {
      output.writeFieldBegin('is_compressed', Thrift.Type.BOOL, 7);
      output.writeBool(this.is_compressed);
      output.writeFieldEnd();
    }
    if (this.statistics !== null && this.statistics !== undefined) {
      output.writeFieldBegin('statistics', Thrift.Type.STRUCT, 8);
      this.statistics.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const SplitBlockAlgorithm = (module.exports.SplitBlockAlgorithm = class {
  constructor(args) {}

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('SplitBlockAlgorithm');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const BloomFilterAlgorithm = (module.exports.BloomFilterAlgorithm = class {
  constructor(args) {
    this.BLOCK = null;
    if (args) {
      if (args.BLOCK !== undefined && args.BLOCK !== null) {
        this.BLOCK = new ttypes.SplitBlockAlgorithm(args.BLOCK);
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.STRUCT) {
            this.BLOCK = new ttypes.SplitBlockAlgorithm();
            this.BLOCK.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('BloomFilterAlgorithm');
    if (this.BLOCK !== null && this.BLOCK !== undefined) {
      output.writeFieldBegin('BLOCK', Thrift.Type.STRUCT, 1);
      this.BLOCK.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const XxHash = (module.exports.XxHash = class {
  constructor(args) {}

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('XxHash');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const BloomFilterHash = (module.exports.BloomFilterHash = class {
  constructor(args) {
    this.XXHASH = null;
    if (args) {
      if (args.XXHASH !== undefined && args.XXHASH !== null) {
        this.XXHASH = new ttypes.XxHash(args.XXHASH);
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.STRUCT) {
            this.XXHASH = new ttypes.XxHash();
            this.XXHASH.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('BloomFilterHash');
    if (this.XXHASH !== null && this.XXHASH !== undefined) {
      output.writeFieldBegin('XXHASH', Thrift.Type.STRUCT, 1);
      this.XXHASH.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const Uncompressed = (module.exports.Uncompressed = class {
  constructor(args) {}

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('Uncompressed');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const BloomFilterCompression = (module.exports.BloomFilterCompression = class {
  constructor(args) {
    this.UNCOMPRESSED = null;
    if (args) {
      if (args.UNCOMPRESSED !== undefined && args.UNCOMPRESSED !== null) {
        this.UNCOMPRESSED = new ttypes.Uncompressed(args.UNCOMPRESSED);
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.STRUCT) {
            this.UNCOMPRESSED = new ttypes.Uncompressed();
            this.UNCOMPRESSED.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('BloomFilterCompression');
    if (this.UNCOMPRESSED !== null && this.UNCOMPRESSED !== undefined) {
      output.writeFieldBegin('UNCOMPRESSED', Thrift.Type.STRUCT, 1);
      this.UNCOMPRESSED.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const BloomFilterHeader = (module.exports.BloomFilterHeader = class {
  constructor(args) {
    this.numBytes = null;
    this.algorithm = null;
    this.hash = null;
    this.compression = null;
    if (args) {
      if (args.numBytes !== undefined && args.numBytes !== null) {
        this.numBytes = args.numBytes;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field numBytes is unset!',
        );
      }
      if (args.algorithm !== undefined && args.algorithm !== null) {
        this.algorithm = new ttypes.BloomFilterAlgorithm(args.algorithm);
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field algorithm is unset!',
        );
      }
      if (args.hash !== undefined && args.hash !== null) {
        this.hash = new ttypes.BloomFilterHash(args.hash);
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field hash is unset!',
        );
      }
      if (args.compression !== undefined && args.compression !== null) {
        this.compression = new ttypes.BloomFilterCompression(args.compression);
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field compression is unset!',
        );
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.I32) {
            this.numBytes = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.STRUCT) {
            this.algorithm = new ttypes.BloomFilterAlgorithm();
            this.algorithm.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 3:
          if (ftype == Thrift.Type.STRUCT) {
            this.hash = new ttypes.BloomFilterHash();
            this.hash.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 4:
          if (ftype == Thrift.Type.STRUCT) {
            this.compression = new ttypes.BloomFilterCompression();
            this.compression.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('BloomFilterHeader');
    if (this.numBytes !== null && this.numBytes !== undefined) {
      output.writeFieldBegin('numBytes', Thrift.Type.I32, 1);
      output.writeI32(this.numBytes);
      output.writeFieldEnd();
    }
    if (this.algorithm !== null && this.algorithm !== undefined) {
      output.writeFieldBegin('algorithm', Thrift.Type.STRUCT, 2);
      this.algorithm.write(output);
      output.writeFieldEnd();
    }
    if (this.hash !== null && this.hash !== undefined) {
      output.writeFieldBegin('hash', Thrift.Type.STRUCT, 3);
      this.hash.write(output);
      output.writeFieldEnd();
    }
    if (this.compression !== null && this.compression !== undefined) {
      output.writeFieldBegin('compression', Thrift.Type.STRUCT, 4);
      this.compression.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const PageHeader = (module.exports.PageHeader = class {
  constructor(args) {
    this.type = null;
    this.uncompressed_page_size = null;
    this.compressed_page_size = null;
    this.crc = null;
    this.data_page_header = null;
    this.index_page_header = null;
    this.dictionary_page_header = null;
    this.data_page_header_v2 = null;
    if (args) {
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field type is unset!',
        );
      }
      if (args.uncompressed_page_size !== undefined && args.uncompressed_page_size !== null) {
        this.uncompressed_page_size = args.uncompressed_page_size;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field uncompressed_page_size is unset!',
        );
      }
      if (args.compressed_page_size !== undefined && args.compressed_page_size !== null) {
        this.compressed_page_size = args.compressed_page_size;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field compressed_page_size is unset!',
        );
      }
      if (args.crc !== undefined && args.crc !== null) {
        this.crc = args.crc;
      }
      if (args.data_page_header !== undefined && args.data_page_header !== null) {
        this.data_page_header = new ttypes.DataPageHeader(args.data_page_header);
      }
      if (args.index_page_header !== undefined && args.index_page_header !== null) {
        this.index_page_header = new ttypes.IndexPageHeader(args.index_page_header);
      }
      if (args.dictionary_page_header !== undefined && args.dictionary_page_header !== null) {
        this.dictionary_page_header = new ttypes.DictionaryPageHeader(args.dictionary_page_header);
      }
      if (args.data_page_header_v2 !== undefined && args.data_page_header_v2 !== null) {
        this.data_page_header_v2 = new ttypes.DataPageHeaderV2(args.data_page_header_v2);
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.I32) {
            this.type = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.I32) {
            this.uncompressed_page_size = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 3:
          if (ftype == Thrift.Type.I32) {
            this.compressed_page_size = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 4:
          if (ftype == Thrift.Type.I32) {
            this.crc = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 5:
          if (ftype == Thrift.Type.STRUCT) {
            this.data_page_header = new ttypes.DataPageHeader();
            this.data_page_header.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 6:
          if (ftype == Thrift.Type.STRUCT) {
            this.index_page_header = new ttypes.IndexPageHeader();
            this.index_page_header.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 7:
          if (ftype == Thrift.Type.STRUCT) {
            this.dictionary_page_header = new ttypes.DictionaryPageHeader();
            this.dictionary_page_header.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 8:
          if (ftype == Thrift.Type.STRUCT) {
            this.data_page_header_v2 = new ttypes.DataPageHeaderV2();
            this.data_page_header_v2.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('PageHeader');
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 1);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.uncompressed_page_size !== null && this.uncompressed_page_size !== undefined) {
      output.writeFieldBegin('uncompressed_page_size', Thrift.Type.I32, 2);
      output.writeI32(this.uncompressed_page_size);
      output.writeFieldEnd();
    }
    if (this.compressed_page_size !== null && this.compressed_page_size !== undefined) {
      output.writeFieldBegin('compressed_page_size', Thrift.Type.I32, 3);
      output.writeI32(this.compressed_page_size);
      output.writeFieldEnd();
    }
    if (this.crc !== null && this.crc !== undefined) {
      output.writeFieldBegin('crc', Thrift.Type.I32, 4);
      output.writeI32(this.crc);
      output.writeFieldEnd();
    }
    if (this.data_page_header !== null && this.data_page_header !== undefined) {
      output.writeFieldBegin('data_page_header', Thrift.Type.STRUCT, 5);
      this.data_page_header.write(output);
      output.writeFieldEnd();
    }
    if (this.index_page_header !== null && this.index_page_header !== undefined) {
      output.writeFieldBegin('index_page_header', Thrift.Type.STRUCT, 6);
      this.index_page_header.write(output);
      output.writeFieldEnd();
    }
    if (this.dictionary_page_header !== null && this.dictionary_page_header !== undefined) {
      output.writeFieldBegin('dictionary_page_header', Thrift.Type.STRUCT, 7);
      this.dictionary_page_header.write(output);
      output.writeFieldEnd();
    }
    if (this.data_page_header_v2 !== null && this.data_page_header_v2 !== undefined) {
      output.writeFieldBegin('data_page_header_v2', Thrift.Type.STRUCT, 8);
      this.data_page_header_v2.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const KeyValue = (module.exports.KeyValue = class {
  constructor(args) {
    this.key = null;
    this.value = null;
    if (args) {
      if (args.key !== undefined && args.key !== null) {
        this.key = args.key;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field key is unset!',
        );
      }
      if (args.value !== undefined && args.value !== null) {
        this.value = args.value;
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.STRING) {
            this.key = input.readString();
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.STRING) {
            this.value = input.readString();
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('KeyValue');
    if (this.key !== null && this.key !== undefined) {
      output.writeFieldBegin('key', Thrift.Type.STRING, 1);
      output.writeString(this.key);
      output.writeFieldEnd();
    }
    if (this.value !== null && this.value !== undefined) {
      output.writeFieldBegin('value', Thrift.Type.STRING, 2);
      output.writeString(this.value);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const SortingColumn = (module.exports.SortingColumn = class {
  constructor(args) {
    this.column_idx = null;
    this.descending = null;
    this.nulls_first = null;
    if (args) {
      if (args.column_idx !== undefined && args.column_idx !== null) {
        this.column_idx = args.column_idx;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field column_idx is unset!',
        );
      }
      if (args.descending !== undefined && args.descending !== null) {
        this.descending = args.descending;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field descending is unset!',
        );
      }
      if (args.nulls_first !== undefined && args.nulls_first !== null) {
        this.nulls_first = args.nulls_first;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field nulls_first is unset!',
        );
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.I32) {
            this.column_idx = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.BOOL) {
            this.descending = input.readBool();
          } else {
            input.skip(ftype);
          }
          break;
        case 3:
          if (ftype == Thrift.Type.BOOL) {
            this.nulls_first = input.readBool();
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('SortingColumn');
    if (this.column_idx !== null && this.column_idx !== undefined) {
      output.writeFieldBegin('column_idx', Thrift.Type.I32, 1);
      output.writeI32(this.column_idx);
      output.writeFieldEnd();
    }
    if (this.descending !== null && this.descending !== undefined) {
      output.writeFieldBegin('descending', Thrift.Type.BOOL, 2);
      output.writeBool(this.descending);
      output.writeFieldEnd();
    }
    if (this.nulls_first !== null && this.nulls_first !== undefined) {
      output.writeFieldBegin('nulls_first', Thrift.Type.BOOL, 3);
      output.writeBool(this.nulls_first);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const PageEncodingStats = (module.exports.PageEncodingStats = class {
  constructor(args) {
    this.page_type = null;
    this.encoding = null;
    this.count = null;
    if (args) {
      if (args.page_type !== undefined && args.page_type !== null) {
        this.page_type = args.page_type;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field page_type is unset!',
        );
      }
      if (args.encoding !== undefined && args.encoding !== null) {
        this.encoding = args.encoding;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field encoding is unset!',
        );
      }
      if (args.count !== undefined && args.count !== null) {
        this.count = args.count;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field count is unset!',
        );
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.I32) {
            this.page_type = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.I32) {
            this.encoding = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 3:
          if (ftype == Thrift.Type.I32) {
            this.count = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('PageEncodingStats');
    if (this.page_type !== null && this.page_type !== undefined) {
      output.writeFieldBegin('page_type', Thrift.Type.I32, 1);
      output.writeI32(this.page_type);
      output.writeFieldEnd();
    }
    if (this.encoding !== null && this.encoding !== undefined) {
      output.writeFieldBegin('encoding', Thrift.Type.I32, 2);
      output.writeI32(this.encoding);
      output.writeFieldEnd();
    }
    if (this.count !== null && this.count !== undefined) {
      output.writeFieldBegin('count', Thrift.Type.I32, 3);
      output.writeI32(this.count);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const ColumnMetaData = (module.exports.ColumnMetaData = class {
  constructor(args) {
    this.type = null;
    this.encodings = null;
    this.path_in_schema = null;
    this.codec = null;
    this.num_values = null;
    this.total_uncompressed_size = null;
    this.total_compressed_size = null;
    this.key_value_metadata = null;
    this.data_page_offset = null;
    this.index_page_offset = null;
    this.dictionary_page_offset = null;
    this.statistics = null;
    this.encoding_stats = null;
    this.bloom_filter_offset = null;
    if (args) {
      if (args.type !== undefined && args.type !== null) {
        this.type = args.type;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field type is unset!',
        );
      }
      if (args.encodings !== undefined && args.encodings !== null) {
        this.encodings = Thrift.copyList(args.encodings, [null]);
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field encodings is unset!',
        );
      }
      if (args.path_in_schema !== undefined && args.path_in_schema !== null) {
        this.path_in_schema = Thrift.copyList(args.path_in_schema, [null]);
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field path_in_schema is unset!',
        );
      }
      if (args.codec !== undefined && args.codec !== null) {
        this.codec = args.codec;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field codec is unset!',
        );
      }
      if (args.num_values !== undefined && args.num_values !== null) {
        this.num_values = args.num_values;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field num_values is unset!',
        );
      }
      if (args.total_uncompressed_size !== undefined && args.total_uncompressed_size !== null) {
        this.total_uncompressed_size = args.total_uncompressed_size;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field total_uncompressed_size is unset!',
        );
      }
      if (args.total_compressed_size !== undefined && args.total_compressed_size !== null) {
        this.total_compressed_size = args.total_compressed_size;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field total_compressed_size is unset!',
        );
      }
      if (args.key_value_metadata !== undefined && args.key_value_metadata !== null) {
        this.key_value_metadata = Thrift.copyList(args.key_value_metadata, [ttypes.KeyValue]);
      }
      if (args.data_page_offset !== undefined && args.data_page_offset !== null) {
        this.data_page_offset = args.data_page_offset;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field data_page_offset is unset!',
        );
      }
      if (args.index_page_offset !== undefined && args.index_page_offset !== null) {
        this.index_page_offset = args.index_page_offset;
      }
      if (args.dictionary_page_offset !== undefined && args.dictionary_page_offset !== null) {
        this.dictionary_page_offset = args.dictionary_page_offset;
      }
      if (args.statistics !== undefined && args.statistics !== null) {
        this.statistics = new ttypes.Statistics(args.statistics);
      }
      if (args.encoding_stats !== undefined && args.encoding_stats !== null) {
        this.encoding_stats = Thrift.copyList(args.encoding_stats, [ttypes.PageEncodingStats]);
      }
      if (args.bloom_filter_offset !== undefined && args.bloom_filter_offset !== null) {
        this.bloom_filter_offset = args.bloom_filter_offset;
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.I32) {
            this.type = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.LIST) {
            this.encodings = [];
            const _rtmp31 = input.readListBegin();
            const _size0 = _rtmp31.size || 0;
            for (let _i2 = 0; _i2 < _size0; ++_i2) {
              let elem3 = null;
              elem3 = input.readI32();
              this.encodings.push(elem3);
            }
            input.readListEnd();
          } else {
            input.skip(ftype);
          }
          break;
        case 3:
          if (ftype == Thrift.Type.LIST) {
            this.path_in_schema = [];
            const _rtmp35 = input.readListBegin();
            const _size4 = _rtmp35.size || 0;
            for (let _i6 = 0; _i6 < _size4; ++_i6) {
              let elem7 = null;
              elem7 = input.readString();
              this.path_in_schema.push(elem7);
            }
            input.readListEnd();
          } else {
            input.skip(ftype);
          }
          break;
        case 4:
          if (ftype == Thrift.Type.I32) {
            this.codec = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 5:
          if (ftype == Thrift.Type.I64) {
            this.num_values = input.readI64();
          } else {
            input.skip(ftype);
          }
          break;
        case 6:
          if (ftype == Thrift.Type.I64) {
            this.total_uncompressed_size = input.readI64();
          } else {
            input.skip(ftype);
          }
          break;
        case 7:
          if (ftype == Thrift.Type.I64) {
            this.total_compressed_size = input.readI64();
          } else {
            input.skip(ftype);
          }
          break;
        case 8:
          if (ftype == Thrift.Type.LIST) {
            this.key_value_metadata = [];
            const _rtmp39 = input.readListBegin();
            const _size8 = _rtmp39.size || 0;
            for (let _i10 = 0; _i10 < _size8; ++_i10) {
              let elem11 = null;
              elem11 = new ttypes.KeyValue();
              elem11.read(input);
              this.key_value_metadata.push(elem11);
            }
            input.readListEnd();
          } else {
            input.skip(ftype);
          }
          break;
        case 9:
          if (ftype == Thrift.Type.I64) {
            this.data_page_offset = input.readI64();
          } else {
            input.skip(ftype);
          }
          break;
        case 10:
          if (ftype == Thrift.Type.I64) {
            this.index_page_offset = input.readI64();
          } else {
            input.skip(ftype);
          }
          break;
        case 11:
          if (ftype == Thrift.Type.I64) {
            this.dictionary_page_offset = input.readI64();
          } else {
            input.skip(ftype);
          }
          break;
        case 12:
          if (ftype == Thrift.Type.STRUCT) {
            this.statistics = new ttypes.Statistics();
            this.statistics.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 13:
          if (ftype == Thrift.Type.LIST) {
            this.encoding_stats = [];
            const _rtmp313 = input.readListBegin();
            const _size12 = _rtmp313.size || 0;
            for (let _i14 = 0; _i14 < _size12; ++_i14) {
              let elem15 = null;
              elem15 = new ttypes.PageEncodingStats();
              elem15.read(input);
              this.encoding_stats.push(elem15);
            }
            input.readListEnd();
          } else {
            input.skip(ftype);
          }
          break;
        case 14:
          if (ftype == Thrift.Type.I64) {
            this.bloom_filter_offset = input.readI64();
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('ColumnMetaData');
    if (this.type !== null && this.type !== undefined) {
      output.writeFieldBegin('type', Thrift.Type.I32, 1);
      output.writeI32(this.type);
      output.writeFieldEnd();
    }
    if (this.encodings !== null && this.encodings !== undefined) {
      output.writeFieldBegin('encodings', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.I32, this.encodings.length);
      for (let iter16 in this.encodings) {
        if (this.encodings.hasOwnProperty(iter16)) {
          iter16 = this.encodings[iter16];
          output.writeI32(iter16);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.path_in_schema !== null && this.path_in_schema !== undefined) {
      output.writeFieldBegin('path_in_schema', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.path_in_schema.length);
      for (let iter17 in this.path_in_schema) {
        if (this.path_in_schema.hasOwnProperty(iter17)) {
          iter17 = this.path_in_schema[iter17];
          output.writeString(iter17);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.codec !== null && this.codec !== undefined) {
      output.writeFieldBegin('codec', Thrift.Type.I32, 4);
      output.writeI32(this.codec);
      output.writeFieldEnd();
    }
    if (this.num_values !== null && this.num_values !== undefined) {
      output.writeFieldBegin('num_values', Thrift.Type.I64, 5);
      output.writeI64(this.num_values);
      output.writeFieldEnd();
    }
    if (this.total_uncompressed_size !== null && this.total_uncompressed_size !== undefined) {
      output.writeFieldBegin('total_uncompressed_size', Thrift.Type.I64, 6);
      output.writeI64(this.total_uncompressed_size);
      output.writeFieldEnd();
    }
    if (this.total_compressed_size !== null && this.total_compressed_size !== undefined) {
      output.writeFieldBegin('total_compressed_size', Thrift.Type.I64, 7);
      output.writeI64(this.total_compressed_size);
      output.writeFieldEnd();
    }
    if (this.key_value_metadata !== null && this.key_value_metadata !== undefined) {
      output.writeFieldBegin('key_value_metadata', Thrift.Type.LIST, 8);
      output.writeListBegin(Thrift.Type.STRUCT, this.key_value_metadata.length);
      for (let iter18 in this.key_value_metadata) {
        if (this.key_value_metadata.hasOwnProperty(iter18)) {
          iter18 = this.key_value_metadata[iter18];
          iter18.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.data_page_offset !== null && this.data_page_offset !== undefined) {
      output.writeFieldBegin('data_page_offset', Thrift.Type.I64, 9);
      output.writeI64(this.data_page_offset);
      output.writeFieldEnd();
    }
    if (this.index_page_offset !== null && this.index_page_offset !== undefined) {
      output.writeFieldBegin('index_page_offset', Thrift.Type.I64, 10);
      output.writeI64(this.index_page_offset);
      output.writeFieldEnd();
    }
    if (this.dictionary_page_offset !== null && this.dictionary_page_offset !== undefined) {
      output.writeFieldBegin('dictionary_page_offset', Thrift.Type.I64, 11);
      output.writeI64(this.dictionary_page_offset);
      output.writeFieldEnd();
    }
    if (this.statistics !== null && this.statistics !== undefined) {
      output.writeFieldBegin('statistics', Thrift.Type.STRUCT, 12);
      this.statistics.write(output);
      output.writeFieldEnd();
    }
    if (this.encoding_stats !== null && this.encoding_stats !== undefined) {
      output.writeFieldBegin('encoding_stats', Thrift.Type.LIST, 13);
      output.writeListBegin(Thrift.Type.STRUCT, this.encoding_stats.length);
      for (let iter19 in this.encoding_stats) {
        if (this.encoding_stats.hasOwnProperty(iter19)) {
          iter19 = this.encoding_stats[iter19];
          iter19.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.bloom_filter_offset !== null && this.bloom_filter_offset !== undefined) {
      output.writeFieldBegin('bloom_filter_offset', Thrift.Type.I64, 14);
      output.writeI64(this.bloom_filter_offset);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const EncryptionWithFooterKey = (module.exports.EncryptionWithFooterKey = class {
  constructor(args) {}

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('EncryptionWithFooterKey');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const EncryptionWithColumnKey = (module.exports.EncryptionWithColumnKey = class {
  constructor(args) {
    this.path_in_schema = null;
    this.key_metadata = null;
    if (args) {
      if (args.path_in_schema !== undefined && args.path_in_schema !== null) {
        this.path_in_schema = Thrift.copyList(args.path_in_schema, [null]);
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field path_in_schema is unset!',
        );
      }
      if (args.key_metadata !== undefined && args.key_metadata !== null) {
        this.key_metadata = args.key_metadata;
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.LIST) {
            this.path_in_schema = [];
            const _rtmp321 = input.readListBegin();
            const _size20 = _rtmp321.size || 0;
            for (let _i22 = 0; _i22 < _size20; ++_i22) {
              let elem23 = null;
              elem23 = input.readString();
              this.path_in_schema.push(elem23);
            }
            input.readListEnd();
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.STRING) {
            this.key_metadata = input.readBinary();
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('EncryptionWithColumnKey');
    if (this.path_in_schema !== null && this.path_in_schema !== undefined) {
      output.writeFieldBegin('path_in_schema', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRING, this.path_in_schema.length);
      for (let iter24 in this.path_in_schema) {
        if (this.path_in_schema.hasOwnProperty(iter24)) {
          iter24 = this.path_in_schema[iter24];
          output.writeString(iter24);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.key_metadata !== null && this.key_metadata !== undefined) {
      output.writeFieldBegin('key_metadata', Thrift.Type.STRING, 2);
      output.writeBinary(this.key_metadata);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const ColumnCryptoMetaData = (module.exports.ColumnCryptoMetaData = class {
  constructor(args) {
    this.ENCRYPTION_WITH_FOOTER_KEY = null;
    this.ENCRYPTION_WITH_COLUMN_KEY = null;
    if (args) {
      if (
        args.ENCRYPTION_WITH_FOOTER_KEY !== undefined &&
        args.ENCRYPTION_WITH_FOOTER_KEY !== null
      ) {
        this.ENCRYPTION_WITH_FOOTER_KEY = new ttypes.EncryptionWithFooterKey(
          args.ENCRYPTION_WITH_FOOTER_KEY,
        );
      }
      if (
        args.ENCRYPTION_WITH_COLUMN_KEY !== undefined &&
        args.ENCRYPTION_WITH_COLUMN_KEY !== null
      ) {
        this.ENCRYPTION_WITH_COLUMN_KEY = new ttypes.EncryptionWithColumnKey(
          args.ENCRYPTION_WITH_COLUMN_KEY,
        );
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.STRUCT) {
            this.ENCRYPTION_WITH_FOOTER_KEY = new ttypes.EncryptionWithFooterKey();
            this.ENCRYPTION_WITH_FOOTER_KEY.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.STRUCT) {
            this.ENCRYPTION_WITH_COLUMN_KEY = new ttypes.EncryptionWithColumnKey();
            this.ENCRYPTION_WITH_COLUMN_KEY.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('ColumnCryptoMetaData');
    if (this.ENCRYPTION_WITH_FOOTER_KEY !== null && this.ENCRYPTION_WITH_FOOTER_KEY !== undefined) {
      output.writeFieldBegin('ENCRYPTION_WITH_FOOTER_KEY', Thrift.Type.STRUCT, 1);
      this.ENCRYPTION_WITH_FOOTER_KEY.write(output);
      output.writeFieldEnd();
    }
    if (this.ENCRYPTION_WITH_COLUMN_KEY !== null && this.ENCRYPTION_WITH_COLUMN_KEY !== undefined) {
      output.writeFieldBegin('ENCRYPTION_WITH_COLUMN_KEY', Thrift.Type.STRUCT, 2);
      this.ENCRYPTION_WITH_COLUMN_KEY.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const ColumnChunk = (module.exports.ColumnChunk = class {
  constructor(args) {
    this.file_path = null;
    this.file_offset = null;
    this.meta_data = null;
    this.offset_index_offset = null;
    this.offset_index_length = null;
    this.column_index_offset = null;
    this.column_index_length = null;
    this.crypto_metadata = null;
    this.encrypted_column_metadata = null;
    if (args) {
      if (args.file_path !== undefined && args.file_path !== null) {
        this.file_path = args.file_path;
      }
      if (args.file_offset !== undefined && args.file_offset !== null) {
        this.file_offset = args.file_offset;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field file_offset is unset!',
        );
      }
      if (args.meta_data !== undefined && args.meta_data !== null) {
        this.meta_data = new ttypes.ColumnMetaData(args.meta_data);
      }
      if (args.offset_index_offset !== undefined && args.offset_index_offset !== null) {
        this.offset_index_offset = args.offset_index_offset;
      }
      if (args.offset_index_length !== undefined && args.offset_index_length !== null) {
        this.offset_index_length = args.offset_index_length;
      }
      if (args.column_index_offset !== undefined && args.column_index_offset !== null) {
        this.column_index_offset = args.column_index_offset;
      }
      if (args.column_index_length !== undefined && args.column_index_length !== null) {
        this.column_index_length = args.column_index_length;
      }
      if (args.crypto_metadata !== undefined && args.crypto_metadata !== null) {
        this.crypto_metadata = new ttypes.ColumnCryptoMetaData(args.crypto_metadata);
      }
      if (args.encrypted_column_metadata !== undefined && args.encrypted_column_metadata !== null) {
        this.encrypted_column_metadata = args.encrypted_column_metadata;
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.STRING) {
            this.file_path = input.readString();
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.I64) {
            this.file_offset = input.readI64();
          } else {
            input.skip(ftype);
          }
          break;
        case 3:
          if (ftype == Thrift.Type.STRUCT) {
            this.meta_data = new ttypes.ColumnMetaData();
            this.meta_data.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 4:
          if (ftype == Thrift.Type.I64) {
            this.offset_index_offset = input.readI64();
          } else {
            input.skip(ftype);
          }
          break;
        case 5:
          if (ftype == Thrift.Type.I32) {
            this.offset_index_length = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 6:
          if (ftype == Thrift.Type.I64) {
            this.column_index_offset = input.readI64();
          } else {
            input.skip(ftype);
          }
          break;
        case 7:
          if (ftype == Thrift.Type.I32) {
            this.column_index_length = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 8:
          if (ftype == Thrift.Type.STRUCT) {
            this.crypto_metadata = new ttypes.ColumnCryptoMetaData();
            this.crypto_metadata.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 9:
          if (ftype == Thrift.Type.STRING) {
            this.encrypted_column_metadata = input.readBinary();
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('ColumnChunk');
    if (this.file_path !== null && this.file_path !== undefined) {
      output.writeFieldBegin('file_path', Thrift.Type.STRING, 1);
      output.writeString(this.file_path);
      output.writeFieldEnd();
    }
    if (this.file_offset !== null && this.file_offset !== undefined) {
      output.writeFieldBegin('file_offset', Thrift.Type.I64, 2);
      output.writeI64(this.file_offset);
      output.writeFieldEnd();
    }
    if (this.meta_data !== null && this.meta_data !== undefined) {
      output.writeFieldBegin('meta_data', Thrift.Type.STRUCT, 3);
      this.meta_data.write(output);
      output.writeFieldEnd();
    }
    if (this.offset_index_offset !== null && this.offset_index_offset !== undefined) {
      output.writeFieldBegin('offset_index_offset', Thrift.Type.I64, 4);
      output.writeI64(this.offset_index_offset);
      output.writeFieldEnd();
    }
    if (this.offset_index_length !== null && this.offset_index_length !== undefined) {
      output.writeFieldBegin('offset_index_length', Thrift.Type.I32, 5);
      output.writeI32(this.offset_index_length);
      output.writeFieldEnd();
    }
    if (this.column_index_offset !== null && this.column_index_offset !== undefined) {
      output.writeFieldBegin('column_index_offset', Thrift.Type.I64, 6);
      output.writeI64(this.column_index_offset);
      output.writeFieldEnd();
    }
    if (this.column_index_length !== null && this.column_index_length !== undefined) {
      output.writeFieldBegin('column_index_length', Thrift.Type.I32, 7);
      output.writeI32(this.column_index_length);
      output.writeFieldEnd();
    }
    if (this.crypto_metadata !== null && this.crypto_metadata !== undefined) {
      output.writeFieldBegin('crypto_metadata', Thrift.Type.STRUCT, 8);
      this.crypto_metadata.write(output);
      output.writeFieldEnd();
    }
    if (this.encrypted_column_metadata !== null && this.encrypted_column_metadata !== undefined) {
      output.writeFieldBegin('encrypted_column_metadata', Thrift.Type.STRING, 9);
      output.writeBinary(this.encrypted_column_metadata);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const RowGroup = (module.exports.RowGroup = class {
  constructor(args) {
    this.columns = null;
    this.total_byte_size = null;
    this.num_rows = null;
    this.sorting_columns = null;
    this.file_offset = null;
    this.total_compressed_size = null;
    this.ordinal = null;
    if (args) {
      if (args.columns !== undefined && args.columns !== null) {
        this.columns = Thrift.copyList(args.columns, [ttypes.ColumnChunk]);
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field columns is unset!',
        );
      }
      if (args.total_byte_size !== undefined && args.total_byte_size !== null) {
        this.total_byte_size = args.total_byte_size;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field total_byte_size is unset!',
        );
      }
      if (args.num_rows !== undefined && args.num_rows !== null) {
        this.num_rows = args.num_rows;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field num_rows is unset!',
        );
      }
      if (args.sorting_columns !== undefined && args.sorting_columns !== null) {
        this.sorting_columns = Thrift.copyList(args.sorting_columns, [ttypes.SortingColumn]);
      }
      if (args.file_offset !== undefined && args.file_offset !== null) {
        this.file_offset = args.file_offset;
      }
      if (args.total_compressed_size !== undefined && args.total_compressed_size !== null) {
        this.total_compressed_size = args.total_compressed_size;
      }
      if (args.ordinal !== undefined && args.ordinal !== null) {
        this.ordinal = args.ordinal;
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.LIST) {
            this.columns = [];
            const _rtmp326 = input.readListBegin();
            const _size25 = _rtmp326.size || 0;
            for (let _i27 = 0; _i27 < _size25; ++_i27) {
              let elem28 = null;
              elem28 = new ttypes.ColumnChunk();
              elem28.read(input);
              this.columns.push(elem28);
            }
            input.readListEnd();
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.I64) {
            this.total_byte_size = input.readI64();
          } else {
            input.skip(ftype);
          }
          break;
        case 3:
          if (ftype == Thrift.Type.I64) {
            this.num_rows = input.readI64();
          } else {
            input.skip(ftype);
          }
          break;
        case 4:
          if (ftype == Thrift.Type.LIST) {
            this.sorting_columns = [];
            const _rtmp330 = input.readListBegin();
            const _size29 = _rtmp330.size || 0;
            for (let _i31 = 0; _i31 < _size29; ++_i31) {
              let elem32 = null;
              elem32 = new ttypes.SortingColumn();
              elem32.read(input);
              this.sorting_columns.push(elem32);
            }
            input.readListEnd();
          } else {
            input.skip(ftype);
          }
          break;
        case 5:
          if (ftype == Thrift.Type.I64) {
            this.file_offset = input.readI64();
          } else {
            input.skip(ftype);
          }
          break;
        case 6:
          if (ftype == Thrift.Type.I64) {
            this.total_compressed_size = input.readI64();
          } else {
            input.skip(ftype);
          }
          break;
        case 7:
          if (ftype == Thrift.Type.I16) {
            this.ordinal = input.readI16();
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('RowGroup');
    if (this.columns !== null && this.columns !== undefined) {
      output.writeFieldBegin('columns', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.columns.length);
      for (let iter33 in this.columns) {
        if (this.columns.hasOwnProperty(iter33)) {
          iter33 = this.columns[iter33];
          iter33.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.total_byte_size !== null && this.total_byte_size !== undefined) {
      output.writeFieldBegin('total_byte_size', Thrift.Type.I64, 2);
      output.writeI64(this.total_byte_size);
      output.writeFieldEnd();
    }
    if (this.num_rows !== null && this.num_rows !== undefined) {
      output.writeFieldBegin('num_rows', Thrift.Type.I64, 3);
      output.writeI64(this.num_rows);
      output.writeFieldEnd();
    }
    if (this.sorting_columns !== null && this.sorting_columns !== undefined) {
      output.writeFieldBegin('sorting_columns', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.sorting_columns.length);
      for (let iter34 in this.sorting_columns) {
        if (this.sorting_columns.hasOwnProperty(iter34)) {
          iter34 = this.sorting_columns[iter34];
          iter34.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.file_offset !== null && this.file_offset !== undefined) {
      output.writeFieldBegin('file_offset', Thrift.Type.I64, 5);
      output.writeI64(this.file_offset);
      output.writeFieldEnd();
    }
    if (this.total_compressed_size !== null && this.total_compressed_size !== undefined) {
      output.writeFieldBegin('total_compressed_size', Thrift.Type.I64, 6);
      output.writeI64(this.total_compressed_size);
      output.writeFieldEnd();
    }
    if (this.ordinal !== null && this.ordinal !== undefined) {
      output.writeFieldBegin('ordinal', Thrift.Type.I16, 7);
      output.writeI16(this.ordinal);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const TypeDefinedOrder = (module.exports.TypeDefinedOrder = class {
  constructor(args) {}

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      input.skip(ftype);
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('TypeDefinedOrder');
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const ColumnOrder = (module.exports.ColumnOrder = class {
  constructor(args) {
    this.TYPE_ORDER = null;
    if (args) {
      if (args.TYPE_ORDER !== undefined && args.TYPE_ORDER !== null) {
        this.TYPE_ORDER = new ttypes.TypeDefinedOrder(args.TYPE_ORDER);
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.STRUCT) {
            this.TYPE_ORDER = new ttypes.TypeDefinedOrder();
            this.TYPE_ORDER.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('ColumnOrder');
    if (this.TYPE_ORDER !== null && this.TYPE_ORDER !== undefined) {
      output.writeFieldBegin('TYPE_ORDER', Thrift.Type.STRUCT, 1);
      this.TYPE_ORDER.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const PageLocation = (module.exports.PageLocation = class {
  constructor(args) {
    this.offset = null;
    this.compressed_page_size = null;
    this.first_row_index = null;
    if (args) {
      if (args.offset !== undefined && args.offset !== null) {
        this.offset = args.offset;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field offset is unset!',
        );
      }
      if (args.compressed_page_size !== undefined && args.compressed_page_size !== null) {
        this.compressed_page_size = args.compressed_page_size;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field compressed_page_size is unset!',
        );
      }
      if (args.first_row_index !== undefined && args.first_row_index !== null) {
        this.first_row_index = args.first_row_index;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field first_row_index is unset!',
        );
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.I64) {
            this.offset = input.readI64();
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.I32) {
            this.compressed_page_size = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 3:
          if (ftype == Thrift.Type.I64) {
            this.first_row_index = input.readI64();
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('PageLocation');
    if (this.offset !== null && this.offset !== undefined) {
      output.writeFieldBegin('offset', Thrift.Type.I64, 1);
      output.writeI64(this.offset);
      output.writeFieldEnd();
    }
    if (this.compressed_page_size !== null && this.compressed_page_size !== undefined) {
      output.writeFieldBegin('compressed_page_size', Thrift.Type.I32, 2);
      output.writeI32(this.compressed_page_size);
      output.writeFieldEnd();
    }
    if (this.first_row_index !== null && this.first_row_index !== undefined) {
      output.writeFieldBegin('first_row_index', Thrift.Type.I64, 3);
      output.writeI64(this.first_row_index);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const OffsetIndex = (module.exports.OffsetIndex = class {
  constructor(args) {
    this.page_locations = null;
    if (args) {
      if (args.page_locations !== undefined && args.page_locations !== null) {
        this.page_locations = Thrift.copyList(args.page_locations, [ttypes.PageLocation]);
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field page_locations is unset!',
        );
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.LIST) {
            this.page_locations = [];
            const _rtmp336 = input.readListBegin();
            const _size35 = _rtmp336.size || 0;
            for (let _i37 = 0; _i37 < _size35; ++_i37) {
              let elem38 = null;
              elem38 = new ttypes.PageLocation();
              elem38.read(input);
              this.page_locations.push(elem38);
            }
            input.readListEnd();
          } else {
            input.skip(ftype);
          }
          break;
        case 0:
          input.skip(ftype);
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('OffsetIndex');
    if (this.page_locations !== null && this.page_locations !== undefined) {
      output.writeFieldBegin('page_locations', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.STRUCT, this.page_locations.length);
      for (let iter39 in this.page_locations) {
        if (this.page_locations.hasOwnProperty(iter39)) {
          iter39 = this.page_locations[iter39];
          iter39.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const ColumnIndex = (module.exports.ColumnIndex = class {
  constructor(args) {
    this.null_pages = null;
    this.min_values = null;
    this.max_values = null;
    this.boundary_order = null;
    this.null_counts = null;
    if (args) {
      if (args.null_pages !== undefined && args.null_pages !== null) {
        this.null_pages = Thrift.copyList(args.null_pages, [null]);
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field null_pages is unset!',
        );
      }
      if (args.min_values !== undefined && args.min_values !== null) {
        this.min_values = Thrift.copyList(args.min_values, [null]);
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field min_values is unset!',
        );
      }
      if (args.max_values !== undefined && args.max_values !== null) {
        this.max_values = Thrift.copyList(args.max_values, [null]);
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field max_values is unset!',
        );
      }
      if (args.boundary_order !== undefined && args.boundary_order !== null) {
        this.boundary_order = args.boundary_order;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field boundary_order is unset!',
        );
      }
      if (args.null_counts !== undefined && args.null_counts !== null) {
        this.null_counts = Thrift.copyList(args.null_counts, [null]);
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.LIST) {
            this.null_pages = [];
            const _rtmp341 = input.readListBegin();
            const _size40 = _rtmp341.size || 0;
            for (let _i42 = 0; _i42 < _size40; ++_i42) {
              let elem43 = null;
              elem43 = input.readBool();
              this.null_pages.push(elem43);
            }
            input.readListEnd();
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.LIST) {
            this.min_values = [];
            const _rtmp345 = input.readListBegin();
            const _size44 = _rtmp345.size || 0;
            for (let _i46 = 0; _i46 < _size44; ++_i46) {
              let elem47 = null;
              elem47 = input.readBinary();
              this.min_values.push(elem47);
            }
            input.readListEnd();
          } else {
            input.skip(ftype);
          }
          break;
        case 3:
          if (ftype == Thrift.Type.LIST) {
            this.max_values = [];
            const _rtmp349 = input.readListBegin();
            const _size48 = _rtmp349.size || 0;
            for (let _i50 = 0; _i50 < _size48; ++_i50) {
              let elem51 = null;
              elem51 = input.readBinary();
              this.max_values.push(elem51);
            }
            input.readListEnd();
          } else {
            input.skip(ftype);
          }
          break;
        case 4:
          if (ftype == Thrift.Type.I32) {
            this.boundary_order = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 5:
          if (ftype == Thrift.Type.LIST) {
            this.null_counts = [];
            const _rtmp353 = input.readListBegin();
            const _size52 = _rtmp353.size || 0;
            for (let _i54 = 0; _i54 < _size52; ++_i54) {
              let elem55 = null;
              elem55 = input.readI64();
              this.null_counts.push(elem55);
            }
            input.readListEnd();
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('ColumnIndex');
    if (this.null_pages !== null && this.null_pages !== undefined) {
      output.writeFieldBegin('null_pages', Thrift.Type.LIST, 1);
      output.writeListBegin(Thrift.Type.BOOL, this.null_pages.length);
      for (let iter56 in this.null_pages) {
        if (this.null_pages.hasOwnProperty(iter56)) {
          iter56 = this.null_pages[iter56];
          output.writeBool(iter56);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.min_values !== null && this.min_values !== undefined) {
      output.writeFieldBegin('min_values', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRING, this.min_values.length);
      for (let iter57 in this.min_values) {
        if (this.min_values.hasOwnProperty(iter57)) {
          iter57 = this.min_values[iter57];
          output.writeBinary(iter57);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.max_values !== null && this.max_values !== undefined) {
      output.writeFieldBegin('max_values', Thrift.Type.LIST, 3);
      output.writeListBegin(Thrift.Type.STRING, this.max_values.length);
      for (let iter58 in this.max_values) {
        if (this.max_values.hasOwnProperty(iter58)) {
          iter58 = this.max_values[iter58];
          output.writeBinary(iter58);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.boundary_order !== null && this.boundary_order !== undefined) {
      output.writeFieldBegin('boundary_order', Thrift.Type.I32, 4);
      output.writeI32(this.boundary_order);
      output.writeFieldEnd();
    }
    if (this.null_counts !== null && this.null_counts !== undefined) {
      output.writeFieldBegin('null_counts', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.I64, this.null_counts.length);
      for (let iter59 in this.null_counts) {
        if (this.null_counts.hasOwnProperty(iter59)) {
          iter59 = this.null_counts[iter59];
          output.writeI64(iter59);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const AesGcmV1 = (module.exports.AesGcmV1 = class {
  constructor(args) {
    this.aad_prefix = null;
    this.aad_file_unique = null;
    this.supply_aad_prefix = null;
    if (args) {
      if (args.aad_prefix !== undefined && args.aad_prefix !== null) {
        this.aad_prefix = args.aad_prefix;
      }
      if (args.aad_file_unique !== undefined && args.aad_file_unique !== null) {
        this.aad_file_unique = args.aad_file_unique;
      }
      if (args.supply_aad_prefix !== undefined && args.supply_aad_prefix !== null) {
        this.supply_aad_prefix = args.supply_aad_prefix;
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.STRING) {
            this.aad_prefix = input.readBinary();
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.STRING) {
            this.aad_file_unique = input.readBinary();
          } else {
            input.skip(ftype);
          }
          break;
        case 3:
          if (ftype == Thrift.Type.BOOL) {
            this.supply_aad_prefix = input.readBool();
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('AesGcmV1');
    if (this.aad_prefix !== null && this.aad_prefix !== undefined) {
      output.writeFieldBegin('aad_prefix', Thrift.Type.STRING, 1);
      output.writeBinary(this.aad_prefix);
      output.writeFieldEnd();
    }
    if (this.aad_file_unique !== null && this.aad_file_unique !== undefined) {
      output.writeFieldBegin('aad_file_unique', Thrift.Type.STRING, 2);
      output.writeBinary(this.aad_file_unique);
      output.writeFieldEnd();
    }
    if (this.supply_aad_prefix !== null && this.supply_aad_prefix !== undefined) {
      output.writeFieldBegin('supply_aad_prefix', Thrift.Type.BOOL, 3);
      output.writeBool(this.supply_aad_prefix);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const AesGcmCtrV1 = (module.exports.AesGcmCtrV1 = class {
  constructor(args) {
    this.aad_prefix = null;
    this.aad_file_unique = null;
    this.supply_aad_prefix = null;
    if (args) {
      if (args.aad_prefix !== undefined && args.aad_prefix !== null) {
        this.aad_prefix = args.aad_prefix;
      }
      if (args.aad_file_unique !== undefined && args.aad_file_unique !== null) {
        this.aad_file_unique = args.aad_file_unique;
      }
      if (args.supply_aad_prefix !== undefined && args.supply_aad_prefix !== null) {
        this.supply_aad_prefix = args.supply_aad_prefix;
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.STRING) {
            this.aad_prefix = input.readBinary();
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.STRING) {
            this.aad_file_unique = input.readBinary();
          } else {
            input.skip(ftype);
          }
          break;
        case 3:
          if (ftype == Thrift.Type.BOOL) {
            this.supply_aad_prefix = input.readBool();
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('AesGcmCtrV1');
    if (this.aad_prefix !== null && this.aad_prefix !== undefined) {
      output.writeFieldBegin('aad_prefix', Thrift.Type.STRING, 1);
      output.writeBinary(this.aad_prefix);
      output.writeFieldEnd();
    }
    if (this.aad_file_unique !== null && this.aad_file_unique !== undefined) {
      output.writeFieldBegin('aad_file_unique', Thrift.Type.STRING, 2);
      output.writeBinary(this.aad_file_unique);
      output.writeFieldEnd();
    }
    if (this.supply_aad_prefix !== null && this.supply_aad_prefix !== undefined) {
      output.writeFieldBegin('supply_aad_prefix', Thrift.Type.BOOL, 3);
      output.writeBool(this.supply_aad_prefix);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const EncryptionAlgorithm = (module.exports.EncryptionAlgorithm = class {
  constructor(args) {
    this.AES_GCM_V1 = null;
    this.AES_GCM_CTR_V1 = null;
    if (args) {
      if (args.AES_GCM_V1 !== undefined && args.AES_GCM_V1 !== null) {
        this.AES_GCM_V1 = new ttypes.AesGcmV1(args.AES_GCM_V1);
      }
      if (args.AES_GCM_CTR_V1 !== undefined && args.AES_GCM_CTR_V1 !== null) {
        this.AES_GCM_CTR_V1 = new ttypes.AesGcmCtrV1(args.AES_GCM_CTR_V1);
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.STRUCT) {
            this.AES_GCM_V1 = new ttypes.AesGcmV1();
            this.AES_GCM_V1.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.STRUCT) {
            this.AES_GCM_CTR_V1 = new ttypes.AesGcmCtrV1();
            this.AES_GCM_CTR_V1.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('EncryptionAlgorithm');
    if (this.AES_GCM_V1 !== null && this.AES_GCM_V1 !== undefined) {
      output.writeFieldBegin('AES_GCM_V1', Thrift.Type.STRUCT, 1);
      this.AES_GCM_V1.write(output);
      output.writeFieldEnd();
    }
    if (this.AES_GCM_CTR_V1 !== null && this.AES_GCM_CTR_V1 !== undefined) {
      output.writeFieldBegin('AES_GCM_CTR_V1', Thrift.Type.STRUCT, 2);
      this.AES_GCM_CTR_V1.write(output);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const FileMetaData = (module.exports.FileMetaData = class {
  constructor(args) {
    this.version = null;
    this.schema = null;
    this.num_rows = null;
    this.row_groups = null;
    this.key_value_metadata = null;
    this.created_by = null;
    this.column_orders = null;
    this.encryption_algorithm = null;
    this.footer_signing_key_metadata = null;
    if (args) {
      if (args.version !== undefined && args.version !== null) {
        this.version = args.version;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field version is unset!',
        );
      }
      if (args.schema !== undefined && args.schema !== null) {
        this.schema = Thrift.copyList(args.schema, [ttypes.SchemaElement]);
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field schema is unset!',
        );
      }
      if (args.num_rows !== undefined && args.num_rows !== null) {
        this.num_rows = args.num_rows;
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field num_rows is unset!',
        );
      }
      if (args.row_groups !== undefined && args.row_groups !== null) {
        this.row_groups = Thrift.copyList(args.row_groups, [ttypes.RowGroup]);
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field row_groups is unset!',
        );
      }
      if (args.key_value_metadata !== undefined && args.key_value_metadata !== null) {
        this.key_value_metadata = Thrift.copyList(args.key_value_metadata, [ttypes.KeyValue]);
      }
      if (args.created_by !== undefined && args.created_by !== null) {
        this.created_by = args.created_by;
      }
      if (args.column_orders !== undefined && args.column_orders !== null) {
        this.column_orders = Thrift.copyList(args.column_orders, [ttypes.ColumnOrder]);
      }
      if (args.encryption_algorithm !== undefined && args.encryption_algorithm !== null) {
        this.encryption_algorithm = new ttypes.EncryptionAlgorithm(args.encryption_algorithm);
      }
      if (
        args.footer_signing_key_metadata !== undefined &&
        args.footer_signing_key_metadata !== null
      ) {
        this.footer_signing_key_metadata = args.footer_signing_key_metadata;
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.I32) {
            this.version = input.readI32();
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.LIST) {
            this.schema = [];
            const _rtmp361 = input.readListBegin();
            const _size60 = _rtmp361.size || 0;
            for (let _i62 = 0; _i62 < _size60; ++_i62) {
              let elem63 = null;
              elem63 = new ttypes.SchemaElement();
              elem63.read(input);
              this.schema.push(elem63);
            }
            input.readListEnd();
          } else {
            input.skip(ftype);
          }
          break;
        case 3:
          if (ftype == Thrift.Type.I64) {
            this.num_rows = input.readI64();
          } else {
            input.skip(ftype);
          }
          break;
        case 4:
          if (ftype == Thrift.Type.LIST) {
            this.row_groups = [];
            const _rtmp365 = input.readListBegin();
            const _size64 = _rtmp365.size || 0;
            for (let _i66 = 0; _i66 < _size64; ++_i66) {
              let elem67 = null;
              elem67 = new ttypes.RowGroup();
              elem67.read(input);
              this.row_groups.push(elem67);
            }
            input.readListEnd();
          } else {
            input.skip(ftype);
          }
          break;
        case 5:
          if (ftype == Thrift.Type.LIST) {
            this.key_value_metadata = [];
            const _rtmp369 = input.readListBegin();
            const _size68 = _rtmp369.size || 0;
            for (let _i70 = 0; _i70 < _size68; ++_i70) {
              let elem71 = null;
              elem71 = new ttypes.KeyValue();
              elem71.read(input);
              this.key_value_metadata.push(elem71);
            }
            input.readListEnd();
          } else {
            input.skip(ftype);
          }
          break;
        case 6:
          if (ftype == Thrift.Type.STRING) {
            this.created_by = input.readString();
          } else {
            input.skip(ftype);
          }
          break;
        case 7:
          if (ftype == Thrift.Type.LIST) {
            this.column_orders = [];
            const _rtmp373 = input.readListBegin();
            const _size72 = _rtmp373.size || 0;
            for (let _i74 = 0; _i74 < _size72; ++_i74) {
              let elem75 = null;
              elem75 = new ttypes.ColumnOrder();
              elem75.read(input);
              this.column_orders.push(elem75);
            }
            input.readListEnd();
          } else {
            input.skip(ftype);
          }
          break;
        case 8:
          if (ftype == Thrift.Type.STRUCT) {
            this.encryption_algorithm = new ttypes.EncryptionAlgorithm();
            this.encryption_algorithm.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 9:
          if (ftype == Thrift.Type.STRING) {
            this.footer_signing_key_metadata = input.readBinary();
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('FileMetaData');
    if (this.version !== null && this.version !== undefined) {
      output.writeFieldBegin('version', Thrift.Type.I32, 1);
      output.writeI32(this.version);
      output.writeFieldEnd();
    }
    if (this.schema !== null && this.schema !== undefined) {
      output.writeFieldBegin('schema', Thrift.Type.LIST, 2);
      output.writeListBegin(Thrift.Type.STRUCT, this.schema.length);
      for (let iter76 in this.schema) {
        if (this.schema.hasOwnProperty(iter76)) {
          iter76 = this.schema[iter76];
          iter76.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.num_rows !== null && this.num_rows !== undefined) {
      output.writeFieldBegin('num_rows', Thrift.Type.I64, 3);
      output.writeI64(this.num_rows);
      output.writeFieldEnd();
    }
    if (this.row_groups !== null && this.row_groups !== undefined) {
      output.writeFieldBegin('row_groups', Thrift.Type.LIST, 4);
      output.writeListBegin(Thrift.Type.STRUCT, this.row_groups.length);
      for (let iter77 in this.row_groups) {
        if (this.row_groups.hasOwnProperty(iter77)) {
          iter77 = this.row_groups[iter77];
          iter77.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.key_value_metadata !== null && this.key_value_metadata !== undefined) {
      output.writeFieldBegin('key_value_metadata', Thrift.Type.LIST, 5);
      output.writeListBegin(Thrift.Type.STRUCT, this.key_value_metadata.length);
      for (let iter78 in this.key_value_metadata) {
        if (this.key_value_metadata.hasOwnProperty(iter78)) {
          iter78 = this.key_value_metadata[iter78];
          iter78.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.created_by !== null && this.created_by !== undefined) {
      output.writeFieldBegin('created_by', Thrift.Type.STRING, 6);
      output.writeString(this.created_by);
      output.writeFieldEnd();
    }
    if (this.column_orders !== null && this.column_orders !== undefined) {
      output.writeFieldBegin('column_orders', Thrift.Type.LIST, 7);
      output.writeListBegin(Thrift.Type.STRUCT, this.column_orders.length);
      for (let iter79 in this.column_orders) {
        if (this.column_orders.hasOwnProperty(iter79)) {
          iter79 = this.column_orders[iter79];
          iter79.write(output);
        }
      }
      output.writeListEnd();
      output.writeFieldEnd();
    }
    if (this.encryption_algorithm !== null && this.encryption_algorithm !== undefined) {
      output.writeFieldBegin('encryption_algorithm', Thrift.Type.STRUCT, 8);
      this.encryption_algorithm.write(output);
      output.writeFieldEnd();
    }
    if (
      this.footer_signing_key_metadata !== null &&
      this.footer_signing_key_metadata !== undefined
    ) {
      output.writeFieldBegin('footer_signing_key_metadata', Thrift.Type.STRING, 9);
      output.writeBinary(this.footer_signing_key_metadata);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
export const FileCryptoMetaData = (module.exports.FileCryptoMetaData = class {
  constructor(args) {
    this.encryption_algorithm = null;
    this.key_metadata = null;
    if (args) {
      if (args.encryption_algorithm !== undefined && args.encryption_algorithm !== null) {
        this.encryption_algorithm = new ttypes.EncryptionAlgorithm(args.encryption_algorithm);
      } else {
        throw new Thrift.TProtocolException(
          Thrift.TProtocolExceptionType.UNKNOWN,
          'Required field encryption_algorithm is unset!',
        );
      }
      if (args.key_metadata !== undefined && args.key_metadata !== null) {
        this.key_metadata = args.key_metadata;
      }
    }
  }

  read(input) {
    input.readStructBegin();
    while (true) {
      const ret = input.readFieldBegin();
      const ftype = ret.ftype;
      const fid = ret.fid;
      if (ftype == Thrift.Type.STOP) {
        break;
      }
      switch (fid) {
        case 1:
          if (ftype == Thrift.Type.STRUCT) {
            this.encryption_algorithm = new ttypes.EncryptionAlgorithm();
            this.encryption_algorithm.read(input);
          } else {
            input.skip(ftype);
          }
          break;
        case 2:
          if (ftype == Thrift.Type.STRING) {
            this.key_metadata = input.readBinary();
          } else {
            input.skip(ftype);
          }
          break;
        default:
          input.skip(ftype);
      }
      input.readFieldEnd();
    }
    input.readStructEnd();
    return;
  }

  write(output) {
    output.writeStructBegin('FileCryptoMetaData');
    if (this.encryption_algorithm !== null && this.encryption_algorithm !== undefined) {
      output.writeFieldBegin('encryption_algorithm', Thrift.Type.STRUCT, 1);
      this.encryption_algorithm.write(output);
      output.writeFieldEnd();
    }
    if (this.key_metadata !== null && this.key_metadata !== undefined) {
      output.writeFieldBegin('key_metadata', Thrift.Type.STRING, 2);
      output.writeBinary(this.key_metadata);
      output.writeFieldEnd();
    }
    output.writeFieldStop();
    output.writeStructEnd();
    return;
  }
});
