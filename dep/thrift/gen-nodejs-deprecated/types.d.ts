//
// Autogenerated by Thrift Compiler (0.13.0)
//
// DO NOT EDIT UNLESS YOU ARE SURE THAT YOU KNOW WHAT YOU ARE DOING
//

type Int64 = number; // TODO

/**
 * Types supported by Parquet.  These types are intended to be used in combination
 * with the encodings to control the on disk storage format.
 * For example INT16 is not included as a type since a good encoding of INT32
 * would handle this.
 */
declare enum Type {
  BOOLEAN = 0,
  INT32 = 1,
  INT64 = 2,
  INT96 = 3,
  FLOAT = 4,
  DOUBLE = 5,
  BYTE_ARRAY = 6,
  FIXED_LEN_BYTE_ARRAY = 7,
}

/**
 * DEPRECATED: Common types used by frameworks(e.g. hive, pig) using parquet.
 * ConvertedType is superseded by LogicalType.  This enum should not be extended.
 *
 * See LogicalTypes.md for conversion between ConvertedType and LogicalType.
 */
declare enum ConvertedType {
  UTF8 = 0,
  MAP = 1,
  MAP_KEY_VALUE = 2,
  LIST = 3,
  ENUM = 4,
  DECIMAL = 5,
  DATE = 6,
  TIME_MILLIS = 7,
  TIME_MICROS = 8,
  TIMESTAMP_MILLIS = 9,
  TIMESTAMP_MICROS = 10,
  UINT_8 = 11,
  UINT_16 = 12,
  UINT_32 = 13,
  UINT_64 = 14,
  INT_8 = 15,
  INT_16 = 16,
  INT_32 = 17,
  INT_64 = 18,
  JSON = 19,
  BSON = 20,
  INTERVAL = 21,
}

/**
 * Representation of Schemas
 */
declare enum FieldRepetitionType {
  REQUIRED = 0,
  OPTIONAL = 1,
  REPEATED = 2,
}

/**
 * Encodings supported by Parquet.  Not all encodings are valid for all types.  These
 * enums are also used to specify the encoding of definition and repetition levels.
 * See the accompanying doc for the details of the more complicated encodings.
 */
declare enum Encoding {
  PLAIN = 0,
  PLAIN_DICTIONARY = 2,
  RLE = 3,
  BIT_PACKED = 4,
  DELTA_BINARY_PACKED = 5,
  DELTA_LENGTH_BYTE_ARRAY = 6,
  DELTA_BYTE_ARRAY = 7,
  RLE_DICTIONARY = 8,
  BYTE_STREAM_SPLIT = 9,
}

/**
 * Supported compression algorithms.
 *
 * Codecs added in format version X.Y can be read by readers based on X.Y and later.
 * Codec support may vary between readers based on the format version and
 * libraries available at runtime.
 *
 * See Compression.md for a detailed specification of these algorithms.
 */
declare enum CompressionCodec {
  UNCOMPRESSED = 0,
  SNAPPY = 1,
  GZIP = 2,
  LZO = 3,
  BROTLI = 4,
  LZ4 = 5,
  ZSTD = 6,
  LZ4_RAW = 7,
}

declare enum PageType {
  DATA_PAGE = 0,
  INDEX_PAGE = 1,
  DICTIONARY_PAGE = 2,
  DATA_PAGE_V2 = 3,
}

/**
 * Enum to annotate whether lists of min/max elements inside ColumnIndex
 * are ordered and if so, in which direction.
 */
declare enum BoundaryOrder {
  UNORDERED = 0,
  ASCENDING = 1,
  DESCENDING = 2,
}

/**
 * Statistics per row group and per page
 * All fields are optional.
 */
declare class Statistics {
  public max: string;
  public min: string;
  public null_count: Int64;
  public distinct_count: Int64;
  public max_value: string;
  public min_value: string;

  constructor(args?: {
    max?: string;
    min?: string;
    null_count?: Int64;
    distinct_count?: Int64;
    max_value?: string;
    min_value?: string;
  });
}

/**
 * Empty structs to use as logical type annotations
 */
declare class StringType {}

declare class UUIDType {}

declare class MapType {}

declare class ListType {}

declare class EnumType {}

declare class DateType {}

/**
 * Logical type to annotate a column that is always null.
 *
 * Sometimes when discovering the schema of existing data, values are always
 * null and the physical type can't be determined. This annotation signals
 * the case where the physical type was guessed from all null values.
 */
declare class NullType {}

/**
 * Decimal logical type annotation
 *
 * To maintain forward-compatibility in v1, implementations using this logical
 * type must also set scale and precision on the annotated SchemaElement.
 *
 * Allowed for physical types: INT32, INT64, FIXED, and BINARY
 */
declare class DecimalType {
  public scale: number;
  public precision: number;

  constructor(args?: { scale: number; precision: number });
}

/**
 * Time units for logical types
 */
declare class MilliSeconds {}

declare class MicroSeconds {}

declare class NanoSeconds {}

declare class TimeUnit {
  public MILLIS: MilliSeconds;
  public MICROS: MicroSeconds;
  public NANOS: NanoSeconds;

  constructor(args?: { MILLIS?: MilliSeconds; MICROS?: MicroSeconds; NANOS?: NanoSeconds });
}

/**
 * Timestamp logical type annotation
 *
 * Allowed for physical types: INT64
 */
declare class TimestampType {
  public isAdjustedToUTC: boolean;
  public unit: TimeUnit;

  constructor(args?: { isAdjustedToUTC: boolean; unit: TimeUnit });
}

/**
 * Time logical type annotation
 *
 * Allowed for physical types: INT32 (millis), INT64 (micros, nanos)
 */
declare class TimeType {
  public isAdjustedToUTC: boolean;
  public unit: TimeUnit;

  constructor(args?: { isAdjustedToUTC: boolean; unit: TimeUnit });
}

/**
 * Integer logical type annotation
 *
 * bitWidth must be 8, 16, 32, or 64.
 *
 * Allowed for physical types: INT32, INT64
 */
declare class IntType {
  public bitWidth: any;
  public isSigned: boolean;

  constructor(args?: { bitWidth: any; isSigned: boolean });
}

/**
 * Embedded JSON logical type annotation
 *
 * Allowed for physical types: BINARY
 */
declare class JsonType {}

/**
 * Embedded BSON logical type annotation
 *
 * Allowed for physical types: BINARY
 */
declare class BsonType {}

/**
 * LogicalType annotations to replace ConvertedType.
 *
 * To maintain compatibility, implementations using LogicalType for a
 * SchemaElement must also set the corresponding ConvertedType (if any)
 * from the following table.
 */
declare class LogicalType {
  public STRING: StringType;
  public MAP: MapType;
  public LIST: ListType;
  public ENUM: EnumType;
  public DECIMAL: DecimalType;
  public DATE: DateType;
  public TIME: TimeType;
  public TIMESTAMP: TimestampType;
  public INTEGER: IntType;
  public UNKNOWN: NullType;
  public JSON: JsonType;
  public BSON: BsonType;
  public UUID: UUIDType;

  constructor(args?: {
    STRING?: StringType;
    MAP?: MapType;
    LIST?: ListType;
    ENUM?: EnumType;
    DECIMAL?: DecimalType;
    DATE?: DateType;
    TIME?: TimeType;
    TIMESTAMP?: TimestampType;
    INTEGER?: IntType;
    UNKNOWN?: NullType;
    JSON?: JsonType;
    BSON?: BsonType;
    UUID?: UUIDType;
  });
}

/**
 * Represents a element inside a schema definition.
 *  - if it is a group (inner node) then type is undefined and num_children is defined
 *  - if it is a primitive type (leaf) then type is defined and num_children is undefined
 * the nodes are listed in depth first traversal order.
 */
declare class SchemaElement {
  public type: Type;
  public type_length: number;
  public repetition_type: FieldRepetitionType;
  public name: string;
  public num_children: number;
  public converted_type: ConvertedType;
  public scale: number;
  public precision: number;
  public field_id: number;
  public logicalType: LogicalType;

  constructor(args?: {
    type?: Type;
    type_length?: number;
    repetition_type?: FieldRepetitionType;
    name: string;
    num_children?: number;
    converted_type?: ConvertedType;
    scale?: number;
    precision?: number;
    field_id?: number;
    logicalType?: LogicalType;
  });
}

/**
 * Data page header
 */
declare class DataPageHeader {
  public num_values: number;
  public encoding: Encoding;
  public definition_level_encoding: Encoding;
  public repetition_level_encoding: Encoding;
  public statistics: Statistics;

  constructor(args?: {
    num_values: number;
    encoding: Encoding;
    definition_level_encoding: Encoding;
    repetition_level_encoding: Encoding;
    statistics?: Statistics;
  });
}

declare class IndexPageHeader {}

/**
 * The dictionary page must be placed at the first position of the column chunk
 * if it is partly or completely dictionary encoded. At most one dictionary page
 * can be placed in a column chunk.
 *
 */
declare class DictionaryPageHeader {
  public num_values: number;
  public encoding: Encoding;
  public is_sorted: boolean;

  constructor(args?: { num_values: number; encoding: Encoding; is_sorted?: boolean });
}

/**
 * New page format allowing reading levels without decompressing the data
 * Repetition and definition levels are uncompressed
 * The remaining section containing the data is compressed if is_compressed is true
 *
 */
declare class DataPageHeaderV2 {
  public num_values: number;
  public num_nulls: number;
  public num_rows: number;
  public encoding: Encoding;
  public definition_levels_byte_length: number;
  public repetition_levels_byte_length: number;
  public is_compressed: boolean;
  public statistics: Statistics;

  constructor(args?: {
    num_values: number;
    num_nulls: number;
    num_rows: number;
    encoding: Encoding;
    definition_levels_byte_length: number;
    repetition_levels_byte_length: number;
    is_compressed?: boolean;
    statistics?: Statistics;
  });
}

/**
 * Block-based algorithm type annotation. *
 */
declare class SplitBlockAlgorithm {}

/**
 * The algorithm used in Bloom filter. *
 */
declare class BloomFilterAlgorithm {
  public BLOCK: SplitBlockAlgorithm;

  constructor(args?: { BLOCK?: SplitBlockAlgorithm });
}

/**
 * Hash strategy type annotation. xxHash is an extremely fast non-cryptographic hash
 * algorithm. It uses 64 bits version of xxHash.
 *
 */
declare class XxHash {}

/**
 * The hash function used in Bloom filter. This function takes the hash of a column value
 * using plain encoding.
 *
 */
declare class BloomFilterHash {
  public XXHASH: XxHash;

  constructor(args?: { XXHASH?: XxHash });
}

/**
 * The compression used in the Bloom filter.
 *
 */
declare class Uncompressed {}

declare class BloomFilterCompression {
  public UNCOMPRESSED: Uncompressed;

  constructor(args?: { UNCOMPRESSED?: Uncompressed });
}

/**
 * Bloom filter header is stored at beginning of Bloom filter data of each column
 * and followed by its bitset.
 *
 */
declare class BloomFilterHeader {
  public numBytes: number;
  public algorithm: BloomFilterAlgorithm;
  public hash: BloomFilterHash;
  public compression: BloomFilterCompression;

  constructor(args?: {
    numBytes: number;
    algorithm: BloomFilterAlgorithm;
    hash: BloomFilterHash;
    compression: BloomFilterCompression;
  });
}

declare class PageHeader {
  public type: PageType;
  public uncompressed_page_size: number;
  public compressed_page_size: number;
  public crc: number;
  public data_page_header: DataPageHeader;
  public index_page_header: IndexPageHeader;
  public dictionary_page_header: DictionaryPageHeader;
  public data_page_header_v2: DataPageHeaderV2;

  constructor(args?: {
    type: PageType;
    uncompressed_page_size: number;
    compressed_page_size: number;
    crc?: number;
    data_page_header?: DataPageHeader;
    index_page_header?: IndexPageHeader;
    dictionary_page_header?: DictionaryPageHeader;
    data_page_header_v2?: DataPageHeaderV2;
  });
}

/**
 * Wrapper struct to store key values
 */
declare class KeyValue {
  public key: string;
  public value: string;

  constructor(args?: { key: string; value?: string });
}

/**
 * Wrapper struct to specify sort order
 */
declare class SortingColumn {
  public column_idx: number;
  public descending: boolean;
  public nulls_first: boolean;

  constructor(args?: { column_idx: number; descending: boolean; nulls_first: boolean });
}

/**
 * statistics of a given page type and encoding
 */
declare class PageEncodingStats {
  public page_type: PageType;
  public encoding: Encoding;
  public count: number;

  constructor(args?: { page_type: PageType; encoding: Encoding; count: number });
}

/**
 * Description for column metadata
 */
declare class ColumnMetaData {
  public type: Type;
  public encodings: Encoding[];
  public path_in_schema: string[];
  public codec: CompressionCodec;
  public num_values: Int64;
  public total_uncompressed_size: Int64;
  public total_compressed_size: Int64;
  public key_value_metadata: KeyValue[];
  public data_page_offset: Int64;
  public index_page_offset: Int64;
  public dictionary_page_offset: Int64;
  public statistics: Statistics;
  public encoding_stats: PageEncodingStats[];
  public bloom_filter_offset: Int64;

  constructor(args?: {
    type: Type;
    encodings: Encoding[];
    path_in_schema: string[];
    codec: CompressionCodec;
    num_values: Int64;
    total_uncompressed_size: Int64;
    total_compressed_size: Int64;
    key_value_metadata?: KeyValue[];
    data_page_offset: Int64;
    index_page_offset?: Int64;
    dictionary_page_offset?: Int64;
    statistics?: Statistics;
    encoding_stats?: PageEncodingStats[];
    bloom_filter_offset?: Int64;
  });
}

declare class EncryptionWithFooterKey {}

declare class EncryptionWithColumnKey {
  public path_in_schema: string[];
  public key_metadata: string;

  constructor(args?: { path_in_schema: string[]; key_metadata?: string });
}

declare class ColumnCryptoMetaData {
  public ENCRYPTION_WITH_FOOTER_KEY: EncryptionWithFooterKey;
  public ENCRYPTION_WITH_COLUMN_KEY: EncryptionWithColumnKey;

  constructor(args?: {
    ENCRYPTION_WITH_FOOTER_KEY?: EncryptionWithFooterKey;
    ENCRYPTION_WITH_COLUMN_KEY?: EncryptionWithColumnKey;
  });
}

declare class ColumnChunk {
  public file_path: string;
  public file_offset: Int64;
  public meta_data: ColumnMetaData;
  public offset_index_offset: Int64;
  public offset_index_length: number;
  public column_index_offset: Int64;
  public column_index_length: number;
  public crypto_metadata: ColumnCryptoMetaData;
  public encrypted_column_metadata: string;

  constructor(args?: {
    file_path?: string;
    file_offset: Int64;
    meta_data?: ColumnMetaData;
    offset_index_offset?: Int64;
    offset_index_length?: number;
    column_index_offset?: Int64;
    column_index_length?: number;
    crypto_metadata?: ColumnCryptoMetaData;
    encrypted_column_metadata?: string;
  });
}

declare class RowGroup {
  public columns: ColumnChunk[];
  public total_byte_size: Int64;
  public num_rows: Int64;
  public sorting_columns: SortingColumn[];
  public file_offset: Int64;
  public total_compressed_size: Int64;
  public ordinal: number;

  constructor(args?: {
    columns: ColumnChunk[];
    total_byte_size: Int64;
    num_rows: Int64;
    sorting_columns?: SortingColumn[];
    file_offset?: Int64;
    total_compressed_size?: Int64;
    ordinal?: number;
  });
}

/**
 * Empty struct to signal the order defined by the physical or logical type
 */
declare class TypeDefinedOrder {}

/**
 * Union to specify the order used for the min_value and max_value fields for a
 * column. This union takes the role of an enhanced enum that allows rich
 * elements (which will be needed for a collation-based ordering in the future).
 *
 * Possible values are:
 * * TypeDefinedOrder - the column uses the order defined by its logical or
 *                      physical type (if there is no logical type).
 *
 * If the reader does not support the value of this union, min and max stats
 * for this column should be ignored.
 */
declare class ColumnOrder {
  public TYPE_ORDER: TypeDefinedOrder;

  constructor(args?: { TYPE_ORDER?: TypeDefinedOrder });
}

declare class PageLocation {
  public offset: Int64;
  public compressed_page_size: number;
  public first_row_index: Int64;

  constructor(args?: { offset: Int64; compressed_page_size: number; first_row_index: Int64 });
}

declare class OffsetIndex {
  public page_locations: PageLocation[];

  constructor(args?: { page_locations: PageLocation[] });
}

/**
 * Description for ColumnIndex.
 * Each <array-field>[i] refers to the page at OffsetIndex.page_locations[i]
 */
declare class ColumnIndex {
  public null_pages: boolean[];
  public min_values: string[];
  public max_values: string[];
  public boundary_order: BoundaryOrder;
  public null_counts: Int64[];

  constructor(args?: {
    null_pages: boolean[];
    min_values: string[];
    max_values: string[];
    boundary_order: BoundaryOrder;
    null_counts?: Int64[];
  });
}

declare class AesGcmV1 {
  public aad_prefix: string;
  public aad_file_unique: string;
  public supply_aad_prefix: boolean;

  constructor(args?: {
    aad_prefix?: string;
    aad_file_unique?: string;
    supply_aad_prefix?: boolean;
  });
}

declare class AesGcmCtrV1 {
  public aad_prefix: string;
  public aad_file_unique: string;
  public supply_aad_prefix: boolean;

  constructor(args?: {
    aad_prefix?: string;
    aad_file_unique?: string;
    supply_aad_prefix?: boolean;
  });
}

declare class EncryptionAlgorithm {
  public AES_GCM_V1: AesGcmV1;
  public AES_GCM_CTR_V1: AesGcmCtrV1;

  constructor(args?: { AES_GCM_V1?: AesGcmV1; AES_GCM_CTR_V1?: AesGcmCtrV1 });
}

/**
 * Description for file metadata
 */
declare class FileMetaData {
  public version: number;
  public schema: SchemaElement[];
  public num_rows: Int64;
  public row_groups: RowGroup[];
  public key_value_metadata: KeyValue[];
  public created_by: string;
  public column_orders: ColumnOrder[];
  public encryption_algorithm: EncryptionAlgorithm;
  public footer_signing_key_metadata: string;

  constructor(args?: {
    version: number;
    schema: SchemaElement[];
    num_rows: Int64;
    row_groups: RowGroup[];
    key_value_metadata?: KeyValue[];
    created_by?: string;
    column_orders?: ColumnOrder[];
    encryption_algorithm?: EncryptionAlgorithm;
    footer_signing_key_metadata?: string;
  });
}

/**
 * Crypto metadata for files with encrypted footer *
 */
declare class FileCryptoMetaData {
  public encryption_algorithm: EncryptionAlgorithm;
  public key_metadata: string;

  constructor(args?: { encryption_algorithm: EncryptionAlgorithm; key_metadata?: string });
}
